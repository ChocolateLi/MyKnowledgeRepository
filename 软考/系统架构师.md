# 系统架构师

# 数据库

完整性约束：

实体完整性约束（primary key）

参照完整性约束(foreign key)

自定义完整性约束(触发器)



候选关键字可以推出所有属性，即可以推出所有属性集。

无损链接：只要包含候选关键字，都是无损连接。



关系代数运算和表达式？

[关系代数运算和表达式](https://blog.csdn.net/qq_34246965/article/details/115960424)

投影(σ)【where】、选择(π)【select】

顺序：π()σ()(表)

自然连接表示两个关系表中有相同名称的属性(列)，则自动作为关联条件，会去除重复的列。

等值连接，取两者笛卡尔积中属性值相等的元组，不会去重重复的。

R X S:表示等值连接，表示笛卡积，不去除重复的列。

R 蝴蝶 S：表示自然连接，会去除重复的列。

关系代数运行效率问题，有一个通用原则，即存在连接操作和选择操作时，尽可能早地完成选择操作，这样可以降低连接操作的数据量，提高运行效率。

相同结果下，自然连接的效率优于笛卡尔积。



数据库设计阶段分为四个阶段：

需求分析：需求说明文档、数据字典、数据流图

概念结构：E-R图

逻辑结构：关系规范化。不讲具体的实现

物理结构：讲具体的实现



商业智能一般由数据仓库、联机分析处理、数据挖掘、数据备份和恢复等部分组成。



数据的转储分为静态转储和动态转储、海量转储和增量转储。

静态转储和动态转储：

1.静态转储不允许对数据库进行任何操作

2.动态转储允许对数据库进行操作，转储和事务可并发执行

海量转储和增量存储：

1.海量转储指每次转储全部数据

2.增量转储指每次只转储上次转储后更新过的数据



存储过程是数据库所提供的一种数据库对象，通过存储过程定义一段代码，提供给应用程序调用来执行。从安全性的角度考虑，更新数据时，通过提供存储过程让第三方调用，将需要的数据传入存储过程，而存储过程内部用代码分别对需要的多个表进行更新，从而避免了向第三方提供系统的表结构，保证了系统的数据安全。



ER图的冲突包括三大类：

* 属性冲突：属性值类型、取值范围或取值集合不同，例如重量有以斤为单位、也有以克为单位
* 命名冲突：同名异义、异名同义
* 结构冲突：同一对象在不同应用中具有不同的抽象



数据库的三级模式：

外模式：视图

模式：表

内模式：存储文件



嵌入式数据库系统，一般只提供本机服务接口，只为前端应用提供基本的数据支持。支持实时数据的管理，同时也支持多线程并发操作。

共享数据库为不同的应用程序提供统一的数据存储与格式定义，能够在一定程度上**缓解**数据语义不一致的问题，但无法完全解决该问题。

基于网络的数据库系统一般是用于嵌入式设备，要求支持可裁剪。

## 范式

规范化的目的：减少冗余，同一含义的数据只存一份

第一范式：原子性，列不可再分，没有重复的列，也没有重复的行

第二范式：非主键属性依赖于整个键，而不是其中一部分

第三范式：非主键属性只依赖于主键属性，不能依赖于其他非主键属性（即不能传递依赖）。



## 两阶段锁

两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段(加锁阶段)和衰退阶段(解锁阶段)

加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。

解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

两段封锁法可以这样来实现：事务开始后就处于加锁阶段，一直到执行ROLLBACK和COMMIT之前都是加锁阶段。ROLLBACK和COMMIT使事务进入解锁阶段，即在ROLLBACK和COMMIT模块中DBMS释放所有封锁。

两段锁协议可以保证事务串行化执行。

两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

![](https://bkimg.cdn.bcebos.com/pic/ac6eddc451da81cb4a2cd0e25266d016082431d2?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U2MA==,g_7,xp_5,yp_5/format,f_auto)

分布式数据库两阶段提交协议中的两个阶段是指表决阶段（准备阶段）和执行阶段（执行阶段）



## 分布式数据库

分布式数据库包括分片透明、复制透明、位置透明和逻辑透明

分片透明：用户不需要知道逻辑上访问的表具体是怎么分块存储的。

复制透明：不需要知道数据是复制到哪些节点

位置透明：不需要知道数据存放的物理位置

逻辑透明：不需要知道局部场地上使用的是哪种数据模型。



分布式数据库体系结构

![](D:\Github\MyKnowledgeRepository\img\ruankao\数据库\分布式数据库结构.png)

全局外模式:是对分布式数据库的最高层的抽象。
全局概念模式:是分布式数据库的整体抽象，包含了系统中全部数据的特性和逻辑结构，描述分布数据库全局数据的逻辑结构，是分布式数据库的全局概念视图。本题描述的是全局概念模式。
分片模式:描述全局数据逻辑划分的视图，是全局数据的逻辑结构根据条件的划分;每一个逻辑划分就是一个片段或称为分片。
分配模式(分布模式):描述局部逻辑的局部物理结构，是划分后的片段(或分片)的物理分配视图;是全局概念层的内容。
局部概念层:由局部概念模式描述，是全局概念模式的子集;全局概念模式经逻辑划分后被分配在各局部场地上。

# 计算机网络

DAS(Direct-Attached Storage)：直连式存储系统，将存储设备连接到服务器上，难以扩展存储容量，而且不支持数据容错，当服务器异常时会造成数据丢失。也可以称SAS(Server-Attached Storage 服务器附加存储)，不带任何存储操作系统。

NAS(Network Attached Storage)：网络接入存储，将存储设备连接到现有网络上，可以直接联网，支持即插即用。不再通过I/O总线附属于某个特定的服务器，直接通过网络相连，用户通过网络访问。有自己的操作系统。

SAN(Storage Area Network)：存储区域网络，是一种连接存储设备和存储管理子系统的专用网络。通过专用高速网将一个或多个网络存储设备和服务器连接起来的专用存储系统。采用数据块的方式进行数据和信息的存储。主要使用于以太网(IPSAN)和光纤通道(FCSAN)。



IPV6的长度是128比特。

IPV6数据包的首部比IPV4简单。

IPV6的地址分为单播、任意播和组播三种。

IPV6被分配到接口，而不是分配给结点，所以每个主机拥有唯一的IPv6地址是错误的。

区分服务 IPv4根据服务类型，IPv6根据通信类型。

IPv6无状态自动配置过程中，主机将其**MAC**地址附加在地址前缀1111111010之后，产生一个链路本地地址。



直连路由管理距离为0，静态路由管理距离为1

路由管理距离小于外部BGP(20)的路由信息是比较可靠的。



正向解析和反向解析都是dns负责。

正向解析：域名到ip地址

反向解析：ip地址到域名，可以通过PTR记录。



DHCP服务器

DHCP是一个局域网的网络协议，指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。

默认情况下，DHCP作为Windows Server的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。

在一个园区网中可以存在多台DHCP服务器。

对于客户端而言，在申请时不知道DHCP服务器地址，因此无法指定。

DHCP客户端收到DHCP服务器回应的DhcpAcK报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送DhcpDecline报文，通知服务器所分配的IP地址不可用。



DNS的配置文件保存在/etc/resolv.conf



交换机属于网络层设备，MAC帧包括：目的地址、源地址等，最开始交换机的MAC地址为空，当传来MAC帧时，将传来的MAC帧的端口和帧的MAC源地址对应为一个表项。分两种情况：

1.转发表没有目的MAC地址的表项，不知道从哪个端口转发，就所有端口转发

2.转发表有目的MAC地址，则对应端口转发。

交换机表项显然是动态增长的



SDN软件定义网络，本质将网络软件化，这样就可以像升级、安装软件一样对网络进行修改、方便更多应用程序能够快速部署到网络上。

SDN网络架构有三层：

* 应用层
* 控制层
* 数据转发层

## 大型局域网

核心层：高速转发通信、可靠性、性能、吞吐要求高，需要双机冗余热备份

汇聚层：网络访问策略控制、数据包处理、过滤、寻址

接入层：直接面向用户连接，负责用户管理的工作。

首先设计接入层，再依次完成各上层的设计。

![](D:\github\MyKnowledgeRepository\img\ruankao\网络设计.png)



## 常见网络协议

IEEE802.3/.2协议是数据链路层协议，局域网协议。

应用层协议：

FTP(文件传输协议)：运行在TCP上，21端口号传递控制信息，20端口号传递内容。

TFTP(简单文件传输协议)：建立在UDP上

HTTP(超文本传输协议)：建立在TCP上

DNS(域名解析)：使用UDP协议，端口号53



网络层协议：

IP、ICMP(网际控制报文协议)、IGMP(网际组管理协议)、ARP(地址解析协议)、RARP(反地址解析协议)

IP是无连接的、不可靠的

IP地址两部组成：网络号+主机号

A类地址：政府使用，1~126，规定以0开头的

B类地址：企业使用，128~191，规定以10开头

C类地址：普通老百姓使用，192~223，规定以110开头

D类地址：组播地址，以1110开头



为了避免IP地址的浪费，创造出了三级IP地址：网络号+子网号+主机号

子网号是从主机号当中借出来的。

子网和超网属于层次化地址编码。

![](D:\github\MyKnowledgeRepository\img\ruankao\子网和子网掩码.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\子网计算.png)

与运算：1&1=1，其他都是0。

例题中，前27位如果一样那就在同一网段，不一样就不在同一网段。

除2取余法

## 网络互联设备

![](D:\github\MyKnowledgeRepository\img\ruankao\网络互联设备.png)



## 综合布线系统

![](D:\github\MyKnowledgeRepository\img\ruankao\综合布线系统.png)

工作区子系统：连接插座的

水平子系统：同一楼层，一端连接插座，一端连接跳线架上。功能：将垂直的子系统延申到工作区，或者将用户区系统引至到管理子系统。连接了干线子系统和工作区子系统。

管理子系统：管理水平和垂直系统的桥梁，同时为同一层组网提供条件

垂直(干线)子系统：各楼层设备之间的互联系统

设备间子系统：

建筑间子系统：当前这个楼和其他的楼连接

​	

IDS：入侵检测系统。根据操作行为特征或异常行径来判断。杀毒软件就用到入侵检测系统的原理，通过特征识别病毒。

防火墙：内外网之间的隔离。外网的请求要到内网，必须通过防火墙，它会使用一些规则判断一些恶意行为。但如果攻击来自内网，防火墙就无能为力了。

网闸：一个物理隔离装置。与IDS和防火墙不同，网闸连接的两个网络是不相通的。与内网相连时，会断开与外网的连接，与外网连接时，会断开与内网的连接。分时地与内外网连接，一个时刻只与一个网络连接，保持“物理的分离”。

UTM：一体化安全设备，具备防火墙、入侵检测和网关防病毒功能。



网络系统生命周期分为5个阶段：需求规范、通信规范、逻辑网络设计、物理网络设计、实施阶段

逻辑网络阶段：根据需求规范和通信规范，实施资源分配和安全规划。

# 操作系统

高速缓存对于程序员来说是透明的。

缓存读取速度比内存快，因为缓存离CPU更近。（CPU > 缓存 > 内存 > 外部存储）

寄存器又叫缓存，存储器又叫内存。



程序计数器PC：存储下一条要执行的指令的地址

指令寄存器IR：存储即将执行的指令

状态寄存器SR：

通过寄存器GR：



CPU访问内存通常是同步方式，CPU与I/O接口交换信息通常是同步方式，CPU与PCI总线交换信息通常是同步方式，I/O接口与打印机交换信息通常采用基于缓存池的异步方式。



操作系统为用户提供了两类接口：

操作一级的接口和程序控制一级的接口。

操作一级的接口包括操作控制命令、菜单命令、窗口等；

程序控制一级的接口包括系统调用



DMA的工作方式是在主存与外设之间建立起直接的数据通路。

## 进程管理

### PV操作

![](D:\github\MyKnowledgeRepository\img\ruankao\操作系统\进程管理-PV.png)



互斥模型：没有协作的

![](D:\github\MyKnowledgeRepository\img\ruankao\操作系统\互斥模型.png)



### 前驱图与PV操作

在前驱图中，箭头流出对应一个V操作，箭头流入对应一个P操作。

![](D:\github\MyKnowledgeRepository\img\ruankao\操作系统\前驱图与PV.png)



相同字母的是间接制约，不同字母的是直接制约。

如：S2和S3受到S1的间接制约，C1和P1受到S1的直接制约。

![](D:\github\MyKnowledgeRepository\img\ruankao\操作系统\直接制约与间接制约.png)



## 存储管理

虚拟存储器是一个逻辑模型，借助磁盘等辅助存储器来扩大容量。所以，虚拟存储器发生页面失效时，需要进行外部地址变换，即实现虚地址到辅存物理地址的变换。



MMU是存储器管理单元，是用来管理虚拟内存系统的器件，MMU通常是CPU的一部分，本身有少量存储空间存放从虚拟地址到物理地址的匹配表。所有数据请求都送往MMU，由MMU决定数据是在RAM空间还是在大容量存储设备内。如果数据不在存储空间内，MMU将产生页面错误中断。



RAID5的存储机制是两块存数据，一块存另外两块硬盘的交易校验结果。RAID5的建立后，坏掉一块硬盘，可以通过另外两块硬盘的数据算出第三块，所以至少要3块。

RAID5适用于大数据量的操作，也适用于各种事务处理。当有N块阵列盘时，用户空间为N-1块盘容量。并且按较小的盘的容量为计算方式。

例如：共有3块80G的硬盘做RAID5，则总容量为(3-1)*80=160G，如果有2块80G的盘和1块40G的盘，总容量为(3-1) * 40=80G



### 磁盘结构

[磁盘结构](https://zhuanlan.zhihu.com/p/373313740)

在磁盘调度管理中，应先进行移臂调度，再进行旋转调度。

移臂找柱面，旋转找扇区。

### 页式存储 

![](D:\github\MyKnowledgeRepository\img\ruankao\操作系统\页式存储1.png)

优先淘汰访问为0的，再淘汰修改为0的。

![](D:\github\MyKnowledgeRepository\img\ruankao\操作系统\页式存储2.png)

分页存储管理：将一个进程的空间地址划分成若干个大小不等的区域，称为页。相应的，将主存空间划分成与页相同大小的若干个物理块，称为块或页框。

![](D:\github\MyKnowledgeRepository\img\ruankao\分页管理.png)

页内地址占12位，页号占20位。

过程：页号通过页表找到对应的物理块号，把块号和块内地址拼接起来就是物理地址。

页内地址等于块内地址，计算公式如上



### 内存计算

1.[内存按字节编址，地址从A4000H到CBFFFH，共有多少个字节呢？](https://blog.csdn.net/weixin_42859280/article/details/90212838)



## 嵌入式系统

嵌入式操作系统的特点：

1.微型化 2.代码质量高 3.专业化 4.实时性强 5.可裁减可配置

由于专业化、软硬件依赖性强，不具有通用性。

针对不同的硬件平台，操作系统通常建立在一个硬件抽象层，该层位于底层硬件和内核之间，为内核提供各种方便移植的宏定义接口，在不同的的平台间的移植时，只需要修改宏定义即可。

![](D:\github\MyKnowledgeRepository\img\ruankao\操作系统\嵌入式操作系统.png)

嵌入式系统采用中断方式实现输入输出的主要原因是能对突发事件做出快速响应。

在中断时，CPU断点信息一般保存到栈中。



嵌入式系统通常采用接口中的**移位寄存器**来实现数据的串/并和并/串转换操作。



在嵌入式系统开发中，由于嵌入式设备不具备足够的处理器能力和存储空间，程序开发一般用PC（宿主机）来完成，然后将可执行文件下载到嵌入式系统（目标机）中运行。

当宿主机和目标机的机器指令不同时，就需要交叉工具链，比如采用交叉编译器来生成目标机的可执行代码。



DSP采用哈佛结构。哈佛结构：数据程序分开。冯诺依曼：数据程序在一块。GPU：冯升级版。

## 实时操作系统

实时性能指标：

* 任务切换时间
* 中断处理相关的时间指标
  * 中断延迟时间
  * 中断处理时间
* 系统响应时间
* 信号量混洗时间（指从一个任务释放信号量到另一个等待信号量的任务被激活的时间延迟）



大多数RTOS系统的调度算法都是抢占式的。



## 鸿蒙系统

鸿蒙系统使用的是**微内核**

系统架构从整体上遵从分层设计，从下向上分为：内核层、系统服务层、框架层、应用层。

系统按照“系统 -> 子系统 -> 功能/模块”逐步逐级展开，支持实际需求裁剪或增加子系统或功能/模块。

鸿蒙系统架构采用了分布式设计理念，实现了分布式软总线、分布式系统的虚拟化、分布式数据管理和分布式任务调度等四种分布式能力。



微内核

优点：1.结构清晰，代码量少 2.可靠性高，安全性强 3.可移植性强，可伸缩性，可扩展性高

缺点：进程通信开销大，内核功能代码不能直接被调用，带来服务效率低。

# 软件工程

## 软件开发方法

**主要开发方法：**

结构化方法：自顶向下

面向对象方法：自底向上

面向服务方法：粗粒度、松耦合、标准化和构件化

原型法：只适用于需求阶段



**其他开发方法：**

形式化方法：数学模型化

统一过程方法

敏捷方法

基于架构的开发方法（ABSD）

基于构件的软件开发（CBSD-Component Base Software Development）



### 结构化方法

结构化分析方法的基本思想：自顶向下，逐层分解，把一个大问题分解成若干个更小的问题，面向数据流的开发方法。

核心是数据字典，有三个层次模型：

数据模型：ER图

功能模型：DFD

行为模型：状态转换图



结构化设计是面向数据流的设计方法，主要包括架构设计、接口设计、数据设计和过程设计。



图与开发阶段的对应关系

需求分析阶段：数据流图

概要设计阶段：模块结构图、层次图、HIPO图

详细设计阶段：程序流程图、伪代码、盒图

### 面向对象方法

面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成。

面向对象设计模型则包含以**包图**表示的软件体系结构图（软件架构图）、以**交互图**表示的**用例实现图**、完整精确的**类图**、针对复杂对象的**状态图**和描述流程化处理过程的**活动图**

面向对象设计的基本任务，把面向对象分析模型转换为面向对象设计模型。

分析 -> 设计 -> 实现

## 软件开发模型

注意：一个开发方法底下可以有多个开发模型



**瀑布模型：**需求明确的时候采用。

**螺旋模型：**以原型为基础+瀑布模型，引入了风险分析，增量和迭代。

**V模型：**测试贯穿始终

**喷泉模型：**早期的面向对象模型

**构件组装模型：**基于构件的开发模型由软件的需求分析定义、体系结构设计、构件库建立、应用软件构建以及测试和发布5个阶段组成。

**快速应用开发模型：**瀑布模型+构件组装模型

**统一过程模型（Rup）：**用例驱动、以架构为中心、增量和迭代

**原型模型：** 主要由原型开发阶段和目标软件开发阶段构成



#### 统一过程模型（RUP）

统一过程模型的特点和原则包括：

1. **迭代与增量**：统一过程模型采用迭代和增量的开发方式，将整个开发过程划分为多个迭代周期。每个迭代周期都包括需求分析、设计、实现和测试等阶段，每个迭代结束时会产生一个可执行的系统部分，逐步完善系统。

2. **用例驱动**：统一过程模型强调用例驱动开发，即以用户需求和功能为中心来组织和驱动开发活动。每个迭代周期都关注实现一组特定的用例，确保系统能够满足用户需求。

3. **架构为中心**：统一过程模型将软件架构置于开发过程的核心位置，通过对系统架构的定义和演化来指导开发活动，确保系统具有良好的设计和扩展性。

4. **风险驱动**：统一过程模型强调对项目风险的管理和控制。通过在早期识别和处理高风险的功能和技术问题，降低项目失败的风险。

5. **迭代的阶段**：统一过程模型包含四个主要阶段：初始阶段、细化阶段、构造阶段和移交阶段。每个阶段又包括多个迭代周期，每个周期都是一个完整的软件开发循环。

6. **可视化和建模**：统一过程模型倡导使用建模工具和可视化技术来描述系统需求、设计和实现，以提高沟通效率和开发质量。



RUP分解为4个顺序阶段：初始阶段、细化阶段、构建阶段和移交阶段。

初始（定义视图、模型、系统范围）、

细化（确定体系结构、制定计划、资源要求）、

构造（构造产品演进需求至产品提交）、

移交（把产品交给用户）



每个阶段结束都要安排一次技术评审，是一个迭代和增量的过程。

4个阶段就是一个开发周期，每次经过这4个阶段就会产生一代软件。但每一次的侧重点都放在不同的阶段上。



好处：软件开发的早期就可以对关键的、影响大的风险进行处理。

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\统一过程开发模型.png)

RUP 4+1 视图：逻辑视图、实现视图、进程视图、部署视图和用例视图

用例视图：分析人员和测试人员关心系统的行为

逻辑视图：最终用户关心的是系统的功能

实现视图：程序员

进程视图：系统集成人员关心的是系统的性能、可伸缩性、吞吐率

部署视图：系统工程师



RUP的9个核心工作流：

商业建模、需求、分析和设计、实现、测试、部署、配置和变更管理、项目管理、环境。

不包括成本。



#### 敏捷开发

**敏捷方法：**轻量级开发，减轻流程负担；适应性的、以人为本、增量迭代，小步快跑、适合小项目；

敏捷四大价值观：沟通（加强面对面沟通）、简单（不过度设计）、反馈（及时反馈）、勇气（接受变更的勇气）

敏捷开发方法的其他模型：

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\敏捷开发方法的一些模型.png)

结构化开发是面向过程的

## 逆向工程

逆向工程是设计的恢复过程

逆向工程导出的信息，4个抽象层次：

1.实现级：包括程序的抽象语法树、符号表等信息

2.结构级：程序分量之间的相互依赖关系，例如调用图、结构图等

3.功能级：程序段功能及程序段之间关系的信息

4.领域级：程序分量或程序与应用领域概念之间对应关系的信息



## 需求工程

需求工程包括需求开发和需求管理。

需求开发：需求获取、需求分析、需求定义、需求验证。

需求管理：变更控制、版本控制、需求跟踪、需求状态跟踪。



需求跟踪，跟踪每一个需求，确定它与系统元素之间的关系。包括编制每个需求与系统元素之间的联系文档



**需求获取**

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\需求获取.png)



**结构化需求分析**

结构化分析方法的基本思想是自顶向下，逐层分解，把一个大问题分成若干个小问题。

结构化分析方法的核心是数据字典，围绕这个核心，有三个层次模型，分别是数据模型、功能模型和行为模型（状态模型）。在实际工作中，一般用ER图表示数据模型，DFD表示功能模型，状态图表示行为模型。

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\结构化需求分析.png)

**需求变更**

需求变更过程包括：问题分析和变更描述、变更分析和成本计算、变更实现



需求变更策略：

1. 所有需求变更必须遵循变更控制过程
2. 对于未获得批准的变更，不应该做设计和实现工作
3. 变更应该由项目变更控制委员会决定实现哪些变更。（变更控制委员可以由一个小组担任，也可以由多个不同的组担任。）
4. 项目风险承担者应该能够了解变更数据库的内容
5. 绝不能从数据库中删除或修改变更请求的原始文档
6. 每一个集成的需求变更必须能跟踪到一个经核准的变更请求



**需求抽取**

需求抽取和分析的过程：

1.发现需求 2.需求分类和组织 3.需求优先级划分和协商 4.需求规格说明



## 系统建模

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\系统建模.png)



## 系统设计

界面设计

结构化设计

面向对象设计

### 人机界面设计

黄金三法则：

* 置于用户控制之下
* 减少用户的记忆负担
* 保持界面一致性



### 软件设计

软件设计包括体系结构设计、接口设计、数据设计和过程设计。

结构设计：定义软件系统各主要部件之间的关系。

接口设计(人机界面设计)：与人如何通信

数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。

过程设计：结构部件转换成软件的过程描述



软件设计可以分为概要设计和详细设计

概要设计称为高层设计或总体设计即将软件需求转化为**数据结构**和软件的**系统结构**；

详细设计也称为低层设计，即对结构图进行细化，得到详细的数据结构与算法。



通过信息隐蔽可以提高软件的可修改性、可测试性和可移植性，是现代软件设计的一个关键性原则。

### 结构化设计

概要设计【外部设计】：功能需求分配给软件模块，确定每一个模块的功能和调用关系，形成模块结构图

详细设计【内部设计】：为每一个具体任务选择适当的技术手段和处理方法



结构化设计原则：

* 模块独立（高内聚低耦合）
* 保持模块的大小适中
* 多扇入（被人调用），少扇出（调用别人）
* 深度和宽度均不可过高



模块的四个要素：

1. 输入和输出。模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再返回给调用者
2. 处理功能。把输入转换成输出所要做的工作
3. 内部数据。模块本身引用的数据
4. 程序代码。实现模块功能的程序



### 面向对象设计

面向对象设计原则：

* 单一原则：设计目的单一的类
* 开放封闭原则：对扩展开放，对修改封闭
* 里氏替换原则：子类可以替换父类。（目的是警示子类不要随便去重写父类的方法）
* 依赖倒置原则：要依赖于抽象，而不是具体的实现；针对接口编程，不要针对实现编程
* 接口隔离原则：使用多个专门的接口比使用单一的总接口要好
* 组合重用原则：要尽量使用组合，而不是继承关系达到重用（继承是一种紧耦合）
* 迪米特原则（最少知识原则）：一个对象应当对其他对象尽可能少的了解



## UML

UML2.0分为基础结构和上层结构两个部分

基础结构：定义一个元模型

上层结构：复用基础结构、提高对基于构件开发的支持



UML2.0引进序列片段，用以表示复数个体组成的选择、分支、循环等逻辑。



UML2.0消息类型：简单消息（返回消息）、同步消息、异步消息、对象创建消息、对象销毁消息、无触发对象消息和无接收对象消息



**事物**

结构事物：静态的部分，包括：类、接口、用例、构件和节点

行为事物：代表时间或空间上的动作，包括：消息、动作次序、连接

分组事物：看成一个盒子，如包、构件

注释事物：UML模型的注释部分



**UML图**

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\UML图.png)





**UML关系理解**

![](D:\github\MyKnowledgeRepository\img\ruankao\UML\UML关系理解.png)



**类图：**

![](D:\github\MyKnowledgeRepository\img\ruankao\UML\类图的关系.png)

依赖：是一种使用关系，我开车，就是一种使用关系。在方法中传入了参数

```java
public void drive(Car car){
    car.move();
}
```

关联关系：是一种拥有关系，它使一个类知道另一个类的属性和方法。一个类拥有了另一个类的成员变量

```java
public class person{
    Car car = new Car();
    car.move()
}
```

聚合关系：是关联关系的一种特例。空心菱形。has-a，整体与部分是可分离的。比如汽车发动机是汽车的组成部分，他们之间是可分离的，所以是聚合关系。

组合关系：也是关联关系的一种特例。实心菱形。contains-a，整体与部分是不可分离的。比如人和头、嘴巴是不可分离的，所以是组合关系。



## 设计模式

**理解模式**

* 架构模式：软件中的高层决策，如C/S、B/S，反应了开发软件系统过程中所作的基本设计决策
* 设计模式：关注软件系统设计，与具体语言无关
* 惯用法：最低层模式，关注软件系统设计与实现，与语言相关



**设计模式分类**

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\设计模式.png)



### 创建型模式

**工厂方法**

速记关键字：动态生产对象

定义一个用于创建对象的接口，让子类决定将哪一个类实例化，使类的实例化延迟到子类。

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\工厂方法模式.png)



**抽象工厂模式**

速记关键字：生产成系列对象

提供一个创建一系列相关的接口，无需指定他们具体的类。

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\抽象工厂模式.png)



**建造者模式**

速记关键字：复杂对象构造

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

典型的kfc儿童套餐包括一个主食、一个辅食、一杯饮料和一个玩具。这些在套餐中可以使不同的，但是组合套餐的过程是相同的。

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\建造者模式.png)



**原型模式**

速记关键字：克隆对象

拷贝原型创建对象

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\原型模式.png)



**单例模式**

速记关键字：单实例

保证一个类只有一个实例



### 结构型模式

**适配器模式**（重点）

速记关键字：转换接口

将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。如：电源适配器

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\适配器模式.png)



**桥接模式**（重点）

速记关键字：继承拆分树

将抽象部分与它的实现部分分离，使他们可以独立地变化。

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\桥接模式.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\桥接模式1.png)



**组合模式**（重点）

速记关键字：树形目录结构

将对象组合成树形结构。

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\组合模式.png)



**装饰器模式**（重点）

速记关键字：动态附加职责

动态地给一个对象添加一个额外的职责。比生成子类更为灵活

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\装饰器模式.png)



**外观模式**

速记关键字：对外统一接口

为子系统一组接口提供一个一致的界面。

使用该模式提高了底层代码访问的一致性，但降低了服务端程序的调用性能。

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\外观模式.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\外观模式1.png)



**享元模式**

速记关键字：汉字编码

运用共享技术有效地复制大量的细粒度对象。

通过共享技术实现相同或相似对象的重用。



**代理模式**

速记关键字：快捷方式

使用代理对象完成用户的请求，屏蔽用户对真实对象的访问。

代理模式和适配器模式的区别：代理模式和被代理者的接口是同一个，适配器模式是接口不同。



### 行为型模式

**责任链模式**（重点）

速记关键字：传递职责

让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

系统需要对敏感词过滤，适合使用责任链模型。



**解释器模式**

速记关键字：虚拟机的机制

给定一个语言，定义它的文法，定义一个解释器，解释器解释该语言中的句子。



**模板方法模式**

速记关键字：框架

定义一个操作中算法的骨架，将一些步骤延迟到子类中。



**命令模式**（重点）

速记关键字：日志记录，可撤销

发出命令的责任和执行命令的责任分割开。可撤销的操作



**迭代器模式**

速记关键字：数据集

提供一种方法顺序访问一个聚合对象中各个元素，而无须暴露该对象的内部表示。



**中介者模式**（重点）

速记关键字：不直接引用

用一个中介对象来封装一系列的对象交互

![](D:\github\MyKnowledgeRepository\img\ruankao\设计模式\中介者模式.png)



**备忘录模式**

速记关键字：游戏存档

在不破坏封装性的前提下，将对象恢复到原先保存的状态。



**观察者模式**（重点）

速记关键字：订阅、广播、联动

观察者模式定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。



**状态模式**（重点）

速记关键字：状态变成类

对于对象内部的状态，允许其在不同的状态下，拥有不同的行为，对状态单独封装成类。



**策略模式**（重点）

速记关键字：多方案切换

定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，让算法独立于它的客户而独立变化。



**访问者模式**

速记关键字：数据与操作分离

对于某个对象或一组对象，不同的访问者，产生的结果不同，执行的操作也不同。



## 软件测试

软件测试的目的是找出存在的错误，软件调试的目的是定位并修改错误。

测试从一个已知条件开始，使用了预先定义的过程，有预知结果；调试从一个未知的条件开始，结束的过程不可预计。

**测试类型**

动态测试

* 黑盒测试
  * 等价类划分
  * 边界值分析
  * 错误猜测
  * 因果图
* 白盒测试
  * 最弱的测试：语句覆盖
  * 最强的测试：路径覆盖
* 灰盒测试（黑 + 白）



在黑盒测试中，判定表方法最适合在描述多个逻辑条件取值组合所构成的复杂情况下，分别要执行哪些不同的动作。



静态测试

* 桌前检查
* 代码审查
* 代码走查

对代码的静态测试包括：

* 控制流分析：使用控制流程图检查
* 数据流分析：数据初始化、赋值或引用过程
* 接口分析：检查函数形参
* 表达式分析：括号不匹配、数组越界、除数为零



基准测试：把应用程序中使用最频繁的那部分核心程序作为评价计算机性能的标准程序



评测程度依次降低：真实程序、核心程序、小型基准程序和合成基准程序。TPC-C是在线事务处理的基准程序，TPC-D是决策支持的基准程序。

**测试阶段**

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\软件测试阶段.png)

Alpha测试：第一阶段，一般只给内部测试使用。

Beta测试：第二阶段，已经消除软件中大部分的不完善之处，但仍有可能存在漏洞，一般只提供给特定的用户群来测试使用。

Landa测试：第三阶段，产品相当成熟，只需个别作进一步优化处理即可上市发行。



集成测试策略

* 一次性组装【风险高】
* 增量式组装【测试全面】
  * 自顶向下【需要桩模块】
  * 自底向上【需要驱动模块】
  * 混合式【都需要】

单元测试也称为模块测试，测试一个模块时，需要为该模块编写一个驱动模块和若干个桩模块。

驱动模块用来调用被测模块，桩模块用来模拟被测模块所调用的子模块。

自顶向下的单元测试先测试上层模块，再测试下层模块。测试下层模块时由于它的上层模块已测试过，所以不必另外编写驱动模块。

自底向上，测试上层模块时由于它的下层模块已经测试过，所以不必另外编写桩模块。



系统测试

* 功能测试
* 性能测试
  * 负载测试：各种工作负载下系统的性能
  * 压力测试：系统的瓶颈或不能接受的性能点
  * 强度测试：系统资源特别低的情况下考查软件极限运行情况
  * 容量测试【并发测试】：同时在线的最大用户数



系统测试是根据系统方案说明书来设计测试用例，路径测试不是系统测试的内容，安装测试属于系统测试的内容。



自动化测试工具主要使用脚本技术来生成测试用例，脚本是一组测试工具执行的指令集合。

脚本的结构有五种：

1. 线性脚本：录制手工测试的测试用例时得到的脚本
2. 结构化脚本：具有逻辑结构和函数调用功能
3. 共享脚本：一个脚本可以被多个测试用例使用
4. 数据驱动脚本：测试输入存储在独立的数据文件中，而不是脚本中
5. 关键字驱动脚本：数据驱动脚本的逻辑扩展，用测试文件描述测试用例。

## 系统演化策略

**遗留系统演化策略**

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\遗留系统演化策略.png)

## 系统运行与维护

* 改正性维护（正确性维护）：改正在系统开发阶段已发生而系统测试阶段尚未发现的错误
* 适应性维护：软件适应环境变化【外部环境、数据环境】而进行的修改
* 完善性维护：扩充功能和改善性能而进行的修改
* 预防性维护：为了适应未来的软硬件变化，主动增加预防性的新功能，以使系统适应各类变化而不被淘汰



## 软件复用

软件架构复用类型包括机会复用和系统复用

* 机会复用：是指**开发过程中**，只要发现有可服用的资产，就对其复用
* 系统复用：是指**在开发之前**，就要进行规划，以决定哪些需要复用。



软件复用过程包括：创建、复用、支持、管理4个过程

主要阶段：构造、管理、使用

# 架构设计

## 架构概念

架构设计主要关注软件组件的结构、属性和**交互作用**，并通过多种**视图**全面描述特定系统的架构。

**架构的本质**

1.软件架构为软件系统提供了一个**结构、行为和属性的高级抽象**

2.软件架构风格是特定应用领域的表达方式和**惯用模式**，架构定义了**一个词汇表和一组约束**



**架构的作用**

1.项目干系人进行交流的手段

2.可传递可复用的模型

3.有助于循序渐进的原型设计



软件架构 = 软件体系结构

架构设计就是需求分配，即将**满足需求的职责分配到组件上**



## 架构4+1视图

对应UML的 4+1 视图

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\架构4+1视图.png)

逻辑视图/设计视图：描述设计的对象模型和对象之间的关系，主要支持系统的功能需求，直接面向最终用户

开发视图/实现视图：描述软件模块的组织与管理，面向开发人员

进程(过程)视图：描述设计的并发和同步特征，关注非功能性需求，面向系统集成人员

物理视图/实施视图：关注软件映射到硬件上，通常要解决系统拓扑结构，面向系统工程人员。

场景视图/用例视图：系统的抽象描述，将上述4个视图有机联系起来。



## 架构风格

架构风格定义了一类架构所共有的特征，反映了领域中众多系统中所有的**结构和语义**两个方面的特征，包括：架构定义、架构词汇表和架构约束。

[架构风格](https://blog.csdn.net/weixin_40972073/article/details/125400460)

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\架构风格.png)



### 数据流风格

数据流风格是支持并行的，但它的交互性比较差。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\数据流风格.png)

批处理和管道过滤器

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\数据流风格-子风格.png)

Web服务在数据传输方面具有协议分层的特征，因此需要数据内容的逐步分解以及分阶段处理。

管道-过滤器的架构风格支持分阶段的数据处理，因此特别适合。



### 调用返回风格

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\调用返回风格.png)

其中分层风格最为重要

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\分层架构风格.png)

分层结构的特点是通过引入抽象层，在较低层次不确定的实现细节在较高层次会变得确定，并能够组织层间构件的协作，系统架构更加清晰。



物联网系统从架构上分为感知层、网络层和应用层

因此属于层次型架构风格。

### 独立构件风格

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\独立构件风格.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\独立构件优缺点.png)

独立构件风格包括进程通信架构风格和事件驱动架构风格。

1.进程通信架构风格中，构件是独立的进程，连接件是消息传递，这种风格的特点是构件通常是命名过程，消息传递的方式可以是点到点，异步和同步方式以及远程过程调用等。

2.事件驱动架构风格中，构件不直接调用一个过程，而是触发或广播一个或多个事件，系统中其他构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程。



Windows操作系统在图形用户界面处理方面采用的是典型的“事件驱动”的架构风格，首先注册事件处理的是回调函数，当某个界面事件发生时（例如键盘敲击、鼠标移动）等，系统会查找并选择合适的回调函数处理事件。



#### 隐式调用

事件驱动又称为隐式调用

对于采用过程调用架构风格的系统，将显示调用策略替换为隐式调用策略能够提高系统的灵活性，但会降低系统的性能。

原理与步骤：

1.维护一个事件注册表

2.监听事件

3.查找注册表记录项和事件一致时，调用。



### 虚拟机风格

类比 java 虚拟机

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\虚拟机风格.png)

#### 解释器

多种组合，灵活的，工作流引擎比较适合，而工作流引擎一般都是解释器执行，因此适合采用解释器架构风格。

原理与步骤：

1.定义和描述语法和语义

2.解释器对定义进行解释

#### 规则为中心

基于规则的系统包括：规则集、规则解释器、规则/数据选择器及工作内存。

### 仓库风格

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\仓库风格.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\仓库风格优缺点.png)



**常考题型：两种架构比较**

| 比较因素 | 管道-过滤器风格        | 数据仓库风格                         |
| -------- | ---------------------- | ------------------------------------ |
| 交互方式 | 顺序结构或有限循环结构 | 工具之间无交互，通过数据仓库间接交互 |
| 数据结构 | 流式数据               | 文件或模型                           |
| 控制结构 | 数据驱动               | 业务功能驱动                         |
| 扩展方式 | 接口适配               | 与数据仓库进行数据适配               |

现代编译器采用以数据共享为中心的架构风格。



在仓库风格中，有两种不同的构件：**中央数据结构**说明当前状态，**独立构件**在中央数据存储上执行。

### 闭环控制风格(过程控制)

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\闭环控制风格.png)

闭环控制风格通常适用于处理简单任务，不适用于复杂的任务。



### C2风格

C2体系结构风格：通过连接件绑定在一起，按照一组规则运作的并行构件网络。

两个构件不允许直接相连，两个连接件可以。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\C2风格.png)



### 层次架构风格

两层C/S -> 三层C/S -> 三层B/S -> 混合架构



#### MVC风格

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\MVC风格.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\MVC风格1.png)





#### MVP风格

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\MVP风格.png)

#### MVVM风格

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\MVVM风格.png)





### 基于服务的架构（SOA)

SOA是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口联系起来。接口是采用中立的方式定义，独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统一和通用的方式进行交互。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\SOA.png)



服务构件对象的关系

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\服务构件对象的关系.png)



#### WEB Service

基于Web Services实现的面向服务系统中，服务提供者、服务使用者和服务注册器之间的远程交互通过**SOAP**（简单对象访问协议）消息实现，服务内容描述通过WSDL（web服务描述语言）标准实现，服务注册信息通过UDDI（服务统一描述、发现和集成）框架实现，通过**BPEL**（业务过程执行语言）将分散的、功能单一的web服务组织成一个复杂的有机应用。

关键技术

发现服务：UDDI

描述服务：WSDL

消息格式层：SOAP、REST

WSDL用来描述服务，UDDI用来注册和查询服务，而SOAP作为传输层，用来在消费者和服务者之间传送消息，一个消费者可以在UDDI注册查找服务，取得服务的WSDL的描述，然后通过SOAP来调用该服务。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\web service.png)

#### ESB（企业服务总线）

ESB的作用与特点：

1、SOA的一种实现方式，ESB在面向服务的架构中起到总线作用，将各种服务进行连接和整合。

2、描述服务的元数据和服务注册管理。

3、在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力。

4、支持服务之间的动态交互，解耦服务请求者和服务提供者。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\ESB架构.png)



#### 微服务和SOA对比

SOA是整，微服务是拆。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\微服务和SOA对比.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\微服务和SOA对比2.png)



### MDA-模型驱动架构

通过映射的方式，通过平台无关模型映射成平台相关模型。一种形式化方法之下的产物

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\MDA.png)



### ADL-架构描述语言

ADL是一种形式化语言

三个基本元素：

构件、连接件、架构配置



### DSSA-特定领域软件架构

DSSA:Domain Specific Software Architecture

针对特定领域来完成架构设计，相当于抽取共性，来完成架构设计。



以特定问题领域为对象，形成由领域参考模型、参考需求、**参考架构**等组成的开发基础架构。



基本活动：

1.领域分析：主要目的是获得**领域模型**

2.领域设计：主要目的是获得**特定领域软件架构**(DSSA)，DSSA描述领域模型中表示需求的解决方案；

3.领域实现：依据领域模型和DSSA 进行实现



三个层次系统模型：

1.领域开发环境：领域架构师

2.领域特定应用开发环境：应用工程师

3.应用执行环境：操作人员



4个角色：

领域专家：主要任务是提供关于领域中系统的需求规约和实现的知识

领域分析人员、

领域设计人员、

领域实现人员

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\DSSA1.png)



## ABSD-基于架构的软件开发方法

又称基于体系结构的软件开发方法



在架构方面，对非功能性需求（性能、可用性、可修改性、安全性）远超过对功能性需求。
三个基础：对系统进行功能分解、采用**架构风格**实现质量属性与商业需求、采用软件模板设计软件结构。

强调采用**视角和视图**来描述软件架构，采用**用例和质量属性场景**来描述需求。用例描述的是功能需求，质量场景描述的是质量需求（非功能需求）



### 概念

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\ABSD.png)

### 开发过程

ABSD方法是一个自顶向下，递归细化的过程，软件系统的架构通过该方法得到细化，直到能产生软件构件和类。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\ABSD2.png)

架构复审要安排一次由外部人员（用户代表和领域专家）参加的复审，复审的过程中，通常会对一个可运行的最小化系统进行架构评估和测试。



**架构需求和架构设计过程**

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\ABSD3.png)

**架构实现和架构演化过程**

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\ABSD4.png)



## 软件架构评估

### 质量属性

刻画质量属性的手段由六部分组成：刺激源、刺激、环境、制品、响应、响应度量

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\架构评估-质量属性.png)

性能：系统响应能力。通常采用资源调度策略、增加系统资源。

可用性：正常运行的时间比例。心跳、冗余策略、ping。

可修改性：方便修改。隐藏信息、运行时注册。灵活性高了修改起来就比较容易。

安全性：阻止非授权用户使用服务的能力。审计追踪、限制访问。



可伸缩性关注的是当用户数和数据量增加时，软件系统维持高服务质量的能力。

#### 性能

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\性能.png)



对运行系统进行评估的主要目的是评价信息系统在性能方面的表现，找出系统可能存在的性能瓶颈。

其中，常见的Web服务器性能评估方法有基准测试、压力测试和可靠性测试等；评价Web服务器的主要性能指标有最大并发连接数、相应延迟和吞吐量等。当系统性能降到基本水平时，需要找出影响性能的瓶颈并消除该瓶颈。



为了优化系统性能，有时需要对系统进行调整。不同系统，调整参数不同。

对于数据库系统，主要包括CPU/内存使用状况、**查询语句性能**、进程/线程使用状态、日志文件大小等。

对于应用系统，主要包括应用系统的可用性、响应时间、**并发用户数**、特定应用资源占用等。

#### 可用性

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\可用性.png)

#### 安全性

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\安全性.png)

* 机密性：保证信息不泄露给未授权的用户、实体或过程
* 完整性：保证信息的完整和准确，防止信息被非法修改
* 不可否认性：防止发送方否认发送过信息
* 可控性：保证对信息的传播及内容具有控制的能力，防止为非法者所用

#### 可修改性

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\可修改性.png)

可修改性包括：可维护性、可扩展性、结构重组、可移植性

#### 易用性和可测试性

想要学习系统特性、有效使用系统、使错误的影响最低、适配系统、对系统满意属于易用性质量属性场景的刺激。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\易用性和可测试性.png)

### 四个点

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\四个点.png)



### 架构评估方法-基于场景的评估方法

在架构评估中，场景是从**风险承担者**的角度对与系统交互的描述，一般采用**刺激、环境、响应**三方面来对场景进行描述。

#### 软件架构分析方法（SAAM）

主要输入：问题描述、需求说明和架构描述

分析过程包括：场景开发、架构描述、单个场景评估、场景交互评估和总体评估

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\SAAM.png)

#### 架构权衡分析法（ATAM）

该框架主要关注系统的需求说明

架构权衡分析方法（ATAM)

是一种系统架构评估方法，关注系统的**需求说明**，主要在系统开发前，针对性能、可用性、安全性和可修改性等质量属性进行评价和折中。

4个主要活动阶段：需求收集、**架构视图描述**、属性模型构造和分析、架构决策与折中，整个过程强调以**属性**作为架构评估的核心概念

在评估过程中，**权衡点**是一个会影响多个质量属性的架构设计决策

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\ATAM.png)

#### 成本效益分析方法（CBAM）

知道它是基于场景的评估方法就行，其他不必过于深究。

### 质量效用树

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\质量效用树.png)

L:低级 M:中级 H:高级

从根部到叶子节点依次为：树根、质量属性、属性分类、质量属性场景

## 构件与中间件

### 构件

软件构件是部署、版本控制和替换的基本单位。是一组通常需要同时部署的原子构件。原子构件通常成组部署，但是也能够单独部署。大多数原子构件都属于一个构件家族。一个模块是不带单独资源的原子构件。

构件是独立部署、不可拆分，对外不可见。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\构件.png)



"构件没有外部可见的状态"通常指的是在软件工程或系统设计中，构件内部的状态对于外部系统是不可见的。这种设计是为了实现封装性和信息隐藏，确保构件的内部状态只能通过指定的接口进行访问和操作，而不会直接暴露给外部系统或其他构件。

这并不意味着构件是不可拆分的，而是指构件内部的实现细节对外部是隐藏的。构件可以通过定义清晰的接口来与外部进行通信，这些接口定义了构件对外暴露的行为和功能，而内部的状态和实现细节则可以自由地修改和调整，只要确保对外接口不受影响即可。这种设计有助于降低系统的复杂度，提高模块化程度，同时也增强了系统的可维护性和扩展性。



基于构件的开发模型由软件的需求分析定义、体系结构设计、构件库建立、应用软件构建以及测试和发布5个阶段组成。



面向构件的编程需要下列基本的支持：多态性(可替代性)、模块封装性(高层次的信息隐藏)、后期绑定和装载(部署独立性)和安全性(类型和模块安全性)。**多模后安**



构件组成软件系统的过程：定制、集成和扩展。



构件分类方法分为三大类：

关键字分类法：从抽象到具体

刻面分类法：Facet

超文本方法：按照人类的联想思维



从构件的外部形态来看，构件可分为五类：

* 独立而成熟的构件：得到实际运行环境的多次检验
* 有限制的构件：指出了使用的条件和前提
* 适应性构件：把不兼容、资源冲突等进行了处理
* 装配构件：装配在操作系统上
* 可修改的构件：进行版本替换并增加构件新功能



**构件与对象**

构件的特性：

1. 独立部署单元
2. 作为第三方的组装单元
3. 没有（外部的）可见状态

一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。将一个类拆分进行部署通常没什么意义



对象的特性：

1. 一个实例单元，具有唯一的标志
2. 可能具有状态，外部可见
3. 封装了自己的状态和行为

### 中间件

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\中间件.png)

中间件优点：

1. 面向需求
2. 业务的分隔和包容性
3. 设计与实现隔离
4. 隔离复杂的系统资源
5. 符合标准的交互模型
6. 软件复用
7. 提供对应用构件的管理



### 构件复用

**复用的历史发展路线**

函数库 -> 类库 -> 构件库 -> 服务库



**复用的维度**

水平复用：不分行业领域，通用

垂直复用：分行业领域，专用



**构件复用流程**

检索与提取构件、理解与评价构件、修改构件、组装构件



检索方法：1.基于关键字检索、2.刻面检索法、3.超文本检索法

构件组装的方式：1.基于功能组装、2.基于数据组装、3.面向对象组装

构件组装成软件系统的过程可以分为三个不同的层次：定制、集成和扩展



### 构件标准

三大构件标准

* CORBA
  * 伺服对象(Servant)：CORBA对象的真正实现，负责完成客户端请求
  * 对象适配器：在底层传输平台与接收调用并返回结果的对象实现之间进行协调
* COM
  * 组件对象模型，是一种软件组件的标准
  * 支持两种形式的对象组装：**包含和聚集**。包含就是一个对象拥有指向另一个对象的唯一引用；聚集是直接把内部对象的接口引用给外部对象，不再转发请求。
* EJB
  * 会话Bean：实现业务逻辑
  * 实体Bean：实现O/R映射
  * 消息驱动Bean：处理并发与异常访问



对象管理组织(OMG)基于CORBA基础设施定义了4种构件标准。

实体构件（Entity）：长期持久化，主要用于事务性行为，由容器管理持久化

加工构件（Process）：由容器管理持久化，但客户端没有可访问的主键

会话构件（Session）：不需要容器管理持久化，状态信息自己管理

服务构件（Service）：无状态的



EJB(Enterprise Java Beans)是运行在独立服务器上的组件

COM+是Microsoft组件对象模型(COM)和Microsoft Transaction Server的演变，可用于开发适用于windows的企业范围。

Servlet(Sever Applet)是Java Servlet的简称，小服务程序

ASP即Active Server Pages，是Microsoft公司开发的服务端脚本环境，可用于创建动态交互网页并建立强大的web应用程序。



服务器端构件模型分为web服务器和应用服务器，EJB和COM+属于应用服务器，Servlet属于web服务器。

# 系统安全分析与设计

## 对称加密和非对称加密

**对称加密**

缺陷：1.加密强度不高，但效率高 2.密钥分发困难

对称加密算法：DES、RC5、IDEA、AES

使用大数据量数据的加密传输



DES加密算法秘钥长度为56位，三重DES的秘钥长度为112位。

WPA2使用了AES加密算法，安全性高。



**非对称加密**

缺陷：加密速度慢

非对称加密算法：RSA、ECC



## 信息摘要

信息摘要：单向散列函数、固定长度的散列值

常见的信息摘要算法有MD5（128位）和SHA（160位）等

作用：防止篡改



## 数字签名

作用：防止抵赖

![](D:\github\MyKnowledgeRepository\img\ruankao\安全\数字签名.png)



## 数字证书

数字证书内容：

* 证书的**版本信息**
* 证书的**序列号**
* 证书使用的签名算法
* 证书的发行机构名称
* 证书的**有效期**
* 证书所有人的名称
* 证书所有人的**公开密钥**（没有私钥）
* **证书发行者对证书签名**



## PKI公钥体系

![](D:\github\MyKnowledgeRepository\img\ruankao\安全\PKI公钥体系.png)

## 网络安全协议

![](D:\github\MyKnowledgeRepository\img\ruankao\安全\网络安全协议.png)

S/MIME可提供安全电子邮件服务

POP3：110端口，邮件收取

SMTP：25端口，邮件发送

IMAP：143端口，邮件客户端可以通过这种协议从邮件服务获取邮件的信息，下载邮件等

## 网络威胁与攻击

被动攻击：收集信息为主，破坏保密性

* 窃听（网络监听）
* 业务流分析
* 非法登录

主动攻击：类别有：中断（破坏可用性）、篡改（破坏完整性）、伪造（破坏真实性）

* 假冒身份
* 抵赖
* 旁路攻击
* 重放攻击。加时间戳可以解决
* 拒绝服务(DOS)



ARP攻击可让攻击者取得局域网上的数据封包甚至可篡改封包，且让网络上特定计算机或所有计算机无法正常连接。

ARP攻击造成网络无法跨网段通信的原因是伪造网关ARP报文使得数据包无法发送到网关。



SYN Flooding是一种常见的DOS(拒绝服务)和DDOS(分布式拒绝服务)攻击方式。使用TCP协议缺陷，发送大量伪造的TCP连接请求，使得被攻击方的CPU或内存资源耗尽，最终导致被攻击方无法提供正常服务。

## 安全保护登记

![image-20230828121959223](D:\github\MyKnowledgeRepository\img\ruankao\安全\安全保护等级1.png)



![image-20230828122224360](D:\github\MyKnowledgeRepository\img\ruankao\安全\安全保护等级2.png)

# 系统可靠性分析与设计

## 相关概念

可靠性是指软件系统在系统错误面前，在意外或错误使用的情况下，维持软件系统的功能特性的基本能力。

可用性是指系统能够正常运行的时间比例。



## 可靠性指标

![image-20230830202254848](D:\github\MyKnowledgeRepository\img\ruankao\可靠性设计\可靠性指标.png)

可靠度是系统在规定工作时间内无故障的概率。

在失效率为常数和修复时间很短的情况下，MTTF和MTBF几乎相等。

MTBF = MTTR + MTTF，当MTTR足够小时，MTTF和MTBF几乎相等。

## 可靠性计算

串并联系统

![image-20230830202610691](D:\github\MyKnowledgeRepository\img\ruankao\可靠性设计\串并联系统.png)

混合系统

![image-20230830202751038](D:\github\MyKnowledgeRepository\img\ruankao\可靠性设计\混合系统.png)



## 可靠性设计

影响软件可靠性的因素：

1. 软件的开发方法和开发环境
2. 运行环境
3. 软件规模
4. 软件内部结构
5. 软件的可靠性投入



**容错技术**

* N版本程序设计（静态冗余）

  ![image-20230830204754434](D:\github\MyKnowledgeRepository\img\ruankao\可靠性设计\N版本程序设计.png)

* 恢复块设计（动态冗余）

  ![image-20230830204826177](D:\github\MyKnowledgeRepository\img\ruankao\可靠性设计\恢复块设计.png)

* 防卫式程序设计（try catch的方式）



**双机容错**

* 双机热备份模式（主系统、备用系统）
* 双机互备模式（同时提供不同的服务，心不跳则接管）
* 双机双工模式（同时提供相同的服务，集群的一种）



# 系统开发基础（零散知识）

软件开发环境包括数据集成、控制集成和界面集成。

环境集成机制：

数据集成：访问信息的统一的数据接口规范

界面集成：统一界面，统一操作

控制集成：支持开发活动之间的通信、切换、调度和协同工作



软件开发环境，根据功能，可以划分为

环境信息库：存储与系统开发有关的信息

过程控制与消息服务器：通信和协同工作

环境用户界面：与用户交互



在对数据库集成中，单表采用主动记录集成，多表采用数据映射进行整合。



当需要集成并灵活定义系统功能之间的协作关系时，应该采用基于**工作流**的功能关系定义方式。	



可行性分析：经济可行性、技术可行性、法律可行性、用户使用可行性



软件活动主要有：1.软件描述 2.软件开发 3.软件有效性验证 4.软件演化

传统软件生命周期：软件定义、软件开发、软件运行、软件维护

按软件过程活动将软件工具分为软件开发工具、软件维护工具、软件管理工具和软件支持工具。

在软件系统工具中，版本控制工具属于软件维护工具，软件评价工具属于软件管理与软件支持工具。



GB强制性国家标准，GB/T推荐性国家标准。



CISC(复杂指令集计算机)的指令系统复杂，难以用硬布线逻辑电路实现控制器，通常采用微程序控制。

RISC (精简指令集计算机)适合采用硬线控制逻辑。

| 指令系统类型 | 指令                               | 寻址方式   | 实现方式                                             | 其它                       |
| ------------ | ---------------------------------- | ---------- | ---------------------------------------------------- | -------------------------- |
| CISC（复杂） | 数量多，使用频率差别大，可变长格式 | 支持多种   | 微程序控制术                                         | 研制周期长                 |
| RISC（简单） | 数据少，使用频率接近，定长格式     | 支持方式少 | 增加了通用寄存器；硬币线逻辑控制为主；适合采用流水线 | 优化编译，有效支持高级语言 |



电子政务的主要4种模式：

1.政府对政府

2.政府对公务员

3.政府对企业

4.政府对公民



参与电子商务活动的实体有4类：客户、商户、银行、认证中心



流水线周期等于时间最长的那个指令周期

流水线的吞吐率 = 指令条数/流水线执行时间

流水线加速比 = 不用流水线的执行时间/使用流水线的执行时间



接口标准化是对接口中的信息的格式、模式和协议的标准化

接口描述是IDL文件中最核心的内容。



Kerberos系统中至少有三个角色：认证服务(AS)、客户端(Client)和普通服务器(Server)。客户端和服务器在AS的帮助下完成相互认证。客户端和服务器都有自己的密码，并且它们的密码只有自己和认证服务器AS知道。客户端在进行认证时，需要先向密钥分发中心来申请初始票据。



模块间相互依赖程度：数据耦合<控制耦合<特征耦合<公共环境耦合<内容耦合

高内聚：功能内聚、顺序内聚

中内聚：过程内聚、通信内聚

低内聚：偶然内聚、逻辑内聚



环形复杂度 = 判定节点 + 1

环形复杂度 = 闭环个数 + 1



软件过程架构结构由4个层次组成：方针、过程、规程和标准规范。

## 企业应用

企业应用集成有三种：

面向信息集成：主要技术数据复制、数据聚合和接口集成

面向过程集成：处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能。

面向服务集成：是一个个web服务或者封装web服务的业务处理，支持服务接口描述和服务处理的分离。



企业信息集成，按照组织范围分，分为内部的信息集成和外部的信息集成。

按照集成内容，可以划分为四个方面：

技术平台集成、

数据集成、

应用系统集成：实现不同系统之间的互操作，使得不同应用系统之间能够实现数据和方法的共享。

业务过程集成：实现不同应用系统的连接、协调和共享。



系统应用集成

基本原则：保证应用程序的独立性

提供4个层次的服务：从下至上依次为：通信服务、信息传递与转化服务、应用连接服务、流程控制服务



企业门户是一个信息技术平台，可以分为三种：

企业信息门户：访问数据时提供统一入口，实现收集、访问、管理无缝集成。

企业知识门户：提供一个知识平台，团队成员取得联系。

企业应用门户：提高企业的集中贸易能力、协同能力和信息管理能力的平台。



企业战略模型可分为数据库模型和数据仓库模型。

数据库模型：描述日常事务处理的关系。

数据仓库模型：描述高层决策所需要的信息。



企业信息化建设：运用信息技术，进行知识挖掘和业务流程管理。

企业信息化方法包括：业务流程重组、核心业务应用、信息系统建设、资源管理和人力资本投资方法。

企业信息资源集成前提是对企业**信息功能**的集成，核心是对企业**内部和外部信息流**的集成

企业信息化对企业管理，将作为管理核心的财务、物料管理，专向技术、物资、人力资源的管理，进而扩展对客户关系和供应链的管理到发展电子商务。

企业信息化一定要建立在企业战略规划基础之上，以企业战略规划为基础建立的企业管理模式是建立企业战略数据模型的依据。



CRM将人力资源、业务流程与专业技术进行有效整合。四个主要模块：销售自动化、营销自动化、客户服务与支持、商业智能。



ERP：物流、资金流和信息流的管理系统。

五个层次生产计划：

生产预测计划：对市场需求进行比较准确地预测

生产计划大纲：根据经营计划的生产目标制定

主生产计划：一定时期内生产什么，生产多少

销售管理计划：对销售部门的相关业务进行管理

物料需求计划：采购

能力需求计划：认识企业生产能力的瓶颈



供应链的信息流覆盖了供应商、制造商和分销商，再到零售商等供应链中的所有环节。

信息流分为需求信息流和供应信息流。

需求信息流：客户订单、生产计划、采购合同

供应信息流：入库单、完工报告单、库存记录等



管理信息系统规划的方法很多：

关键成功因素法：通过对关键成功因素的识别...

战略目标集转化法：组织的战略目标转变为管理信息系统的战略目标

企业系统规划法：自上而下地识别企业目标...，自下而上地设计信息系统



关键成功因素法通过对关键成功因素的识别，找出实现目标所需要的关键信息集合，从而确定系统开发的**优先次序**。关键成功因素来源于组织的目标，通过组织的目标分解和关键成功因素识别、**性能指标**识别，一直到产生数据字典。



信息化需求包括三个层次：战略需求、运作需求和技术需求。

战略需求提升组织的竞争能力，运作需求实现信息化战略目标的需求、运营策略、人才培养。

技术需求系统开发之类的...



企业数字化转型的五个发展阶段：初始级、单元级、流程级、网络级、生态级



## 分布式

分布式系统分为5个逻辑计算层：

表示层：实现用户界面

表示逻辑层：生成数据表示而必须进行的处理任务，如输入数据编辑等

应用逻辑层：支持业务的处理过程，数据计算和分析

数据处理层：存储和访问数据库，查询语句和存储过程

数据层：实际存储的业务数据



客户机/服务器系统开发时可以采用不同的分布式计算架构。

分布式表示架构：表示层和表示逻辑层在客户机，应用逻辑层、数据处理层和数据层仍在服务器

分布式数据架构：表示层、表示逻辑层、应用逻辑层在客户机，数据处理层和数据层在服务器

分布式数据和应用架构：表示层和表示逻辑层在客户机、应用逻辑层在应用服务器上，数据处理层和数据层在数据服务器上。



## AI

[AI芯片架构](https://zhuanlan.zhihu.com/p/665210461)



最新英伟达 4090 GPU达到了100 TFLOPs算力

Flops即每秒浮点运算次数，评估电脑效能，s代表秒，而不是复数。

- 一个MFLOPS（megaFLOPS）等于每秒一百万（=10^6）次的浮点运算，

- 一个GFLOPS（gigaFLOPS）等于每秒十亿（=10^9）次的浮点运算，

- 一个TFLOPS（teraFLOPS）等于每秒一万亿（=10^12）次的浮点运算，

- 一个PFLOPS（petaFLOPS）等于每秒一千万亿（=10^15）次的浮点运算，

- 一个EFLOPS（exaFLOPS）等于每秒一百亿亿（=10^18）次的浮点运算。

  

常用的AI芯片的技术架构包括：GPU、FPGA、ASIC



AI的关键特点：新型的计算范式、训练和推断、大数据处理能力、可重构的能力

## 云计算

云计算服务，从上到下具有三种服务方式：

* SaaS：软件即服务
* PaaS：平台即服务
* IaaS：基础设施即服务



## 大数据

数据资产的特性包括：

可控制、可量化、可变现、

虚拟性、共享性、时效性、安全性、交换性和规模性



数据管理能力成熟度评估模型（DCMM），包括8个内容：

数据战略、数据治理（战略、治理）

数据架构、数据标准（架构、标准）

数据质量、数据安全（质量、安全）

数据应用、数据生存周期（应用、周期）



## 区块链

区块链最成功的应用比特币，矿工的“挖矿”行为，动机是为了获得代币奖励（用某种数字货币代替现金作为奖励）

其本质是尝试计算一个Hash碰撞，从而完成工作量的证明

对社区而言，成功挖矿的矿工获得记账权和代币奖励，是区块链应用系统的奖励机制，是社区自我维持的关键。

然而，挖矿行为自身不能防止双花攻击（一笔钱可以花出去两次）



# 项目管理

项目范围是为了达到项目目标、为了交付具有某种特制的产品和服务，项目所规定要做的。

产品范围是指信息系统产品或服务所应该包含的功能，项目范围是指为了能够交付信息系统项目所必须做的工作。

产品范围是项目范围的基础，产品范围定义是信息系统要求的度量，而项目范围的定义是生产项目计划的基础。

产品范围的描述是项目范围说明书的重要组成部分。

项目范围定义的输入包括以下内容：

1.项目章程

2.项目范围管理计划

3.组织过程资产

4.批准的变更申请



项目文档管理方案、项目合同文本不属于范围定义的输入。



配置项主要有两大类：

1.产品：需求文档、设计文档、源代码、测试用例

2.项目管理：工作计划、项目质量报告、项目跟踪报告

需求文档和设计文档归属于文档



配置项的状态有3种：草稿、正式发布和正在修改。



项目的成本管理中，**成本预算**将总的成本估算分配到各项活动和工作包上，来建立一个成本的基线。



项目时间管理中的过程包括活动定义、活动排序、活动的资源估算、活动历时估算、制定进度计划以及进度控制。



## 盈亏平衡

![](D:\github\MyKnowledgeRepository\img\ruankao\项目管理\盈亏平衡.png)



## 范围管理

![](D:\github\MyKnowledgeRepository\img\ruankao\项目管理\范围管理.png)



## 时间管理(进度管理)

### 概念

![](D:\github\MyKnowledgeRepository\img\ruankao\项目管理\时间管理1.png)



### 单代号网络图（Pert）

总时差为0的为关键路径，关键路径可以有多条，但越少越好。少代表着项目自由度更高。

总时差=LF-EF=LS-ES

自由时差总是小于或等于总时差。拿节点B举例，其自由时差=紧后开始时间-紧前结束时间=13-7=6

在自由时差之内的延误不会对别人产生影响

关键路径选长的那条

![](D:\github\MyKnowledgeRepository\img\ruankao\项目管理\时间管理-单代号网络图.png)

### 双代号网络图

![](D:\Github\MyKnowledgeRepository\img\ruankao\项目管理\时间管理-双代号网络图.png)



### 甘特图

![](D:\Github\MyKnowledgeRepository\img\ruankao\项目管理\时间管理-甘特图.png)



## 成本管理

### 概念

![](D:\Github\MyKnowledgeRepository\img\ruankao\项目管理\成本管理.png)

### 挣值管理

![](D:\Github\MyKnowledgeRepository\img\ruankao\项目管理\成本管理-挣值管理.png)

## 质量管理

质量保证(QA):独特工具包括质量审计和过程分析。

质量控制(QC):比较关注具体的结果。

质量控制的结果也是质量保证的审计对象

### CMMI

CMMI 软件能力成熟度

* 1级：初始级
* 2级：已管理级。项目级可重复。
* 3级：已定义级。组织级，文档化标准化。
* 4级：量化管理级
* 5级：优化级

![](D:\Github\MyKnowledgeRepository\img\ruankao\项目管理\质量管理-CMMI.png)

## 软件配置管理

### 配置项与配置库

![](D:\Github\MyKnowledgeRepository\img\ruankao\项目管理\配置管理-配置项.png)

### 版本控制

![](D:\Github\MyKnowledgeRepository\img\ruankao\项目管理\配置管理-版本控制.png)

# 保护法

著作权不保护思想，因此可以通过反编译技术获得他人软件所使用的思路，并直接用于自己的软件产品中，不构成侵权。



即使未签劳动合同，在公司开发的软件软件著作权仍然属于公司。



著作权法规定：作者的署名权、修改权、保护作品完整权的保护期不受限制。

发表权、使用权的保护期受时间限制，作者终生及其死后的50年。



受他人委托开发的软件，其著作权的归属由委托者与受委托者签订书面协议约定，如无书面协议或在协议中未明确规定，其著作权属于受委托者。



发明专利保护期为20年、实用型专利和外观设计专利为10年

商标权为10年、软件著作为50年。



改编作品的著作权归属于改编人



合作作品的著作权归属于所有参与人，不含组织创作人。

# 案例分析

重点内容：

软件架构设计：软件架构设计（必考）、软件质量属性（第一、重点）、架构模型（风格）（第二、重点）、架构评估

设计模式：设计模式分类

系统设计：数据库设计、中间件以及应用服务器、性能设计与性能评估



试题解答步骤：

* 标出问题要点，以此分析和思考
* 对照问题要点，仔细分析全文
* 通过定性分析和定量计算，构思答案
* 以最精简的语言写出答案

## 软件工程

### 需求分析

#### 结构化分析

结构化分析方法的基本思想：自顶向下，逐层分解，把一个大问题分解成若干个更小的问题。

核心是数据字典，有三个层次模型：

数据模型：ER图

功能模型：DFD

行为模型：状态转换图



结构化分析方法的基本思想是自顶向下，逐层分解，把一个大问题分成若干个小问题。

结构化分析方法的核心是数据字典，围绕这个核心，有三个层次模型，分别是数据模型、功能模型和行为模型（状态模型）。在实际工作中，一般用ER图表示数据模型，DFD表示功能模型，状态图表示行为模型。

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\结构化需求分析.png)



自顶向下分析

**数据流图**

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\数据流图.png)



![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\数据流图的分层结构.png)



![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\数据流图顶层图和0层图.png)

平衡原则：父子图平衡

异常问题：

黑洞：一个加工只有输入流而没有输出流

奇迹：一个加工只有输出流而没有输入流

灰洞：一个加工的输入流无法通过加工产生输出流



**答题技巧**

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\数据流图答题技巧1.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\数据流图答题技巧2.png)





### UML图

![](D:\github\MyKnowledgeRepository\img\ruankao\UML\UML整体分类.png)



#### 用例图

![](D:\github\MyKnowledgeRepository\img\ruankao\UML\用例图.png)

注意：时间是可以作为参与者，比如每个月要报表，那么时间就是触发报表生成的参与因素。同理温度也是如此



**用例图关系**

包含关系：提取公共的部分，是必须选择的，必须要先执行了箭头指向的用例，才可以执行箭头末尾的用例。

扩展关系：是可选的，不一定要执行。比如箭头指向的用例执行了，箭头尾向的用例不一定执行。

泛化关系：一定可以呈现父子关系，而包含关系不一定呈现。

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\用例图关系.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\用例关系2.png)

**细化用例描述**

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\用例规约.png)



#### 类图

![](D:\github\MyKnowledgeRepository\img\ruankao\UML\类图与对象图.png)

**多重度**

![](D:\github\MyKnowledgeRepository\img\ruankao\UML\类图的多重度.png)



**类图关系**

聚合关系：整体消亡了，部分还可以存在，生命周期不同。

组合关系：整体消亡了，部分也消亡，生命周期相同。

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\类图关系.png)



#### 顺序图

强调消息的时间顺序

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\顺序图.png)



#### 通信图（协作图）

强调消息的收发关系，谁发送，谁接收。

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\通信图.png)



#### 状态图

方框内是状态

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\状态图.png)



#### 活动图

方框内是活动

两条黑色的粗线表示可以并行执行的

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\活动图.png)

泳道活动图

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\泳道活动图.png)



#### 部署图

系统已经开发完毕了，如何去部署软件硬件的问题。

![](D:\github\MyKnowledgeRepository\img\ruankao\软件工程\部署图.png)

### 真题

**1.数据流图和系统流程图之间有哪些方面的区别**

共同点：都是结构化建模的工具，帮助开发人员更好地分析和设计系统，增强开发人员之间交流的准确性和有效性。

不同点：

1.数据流图展现系统的数据流；系统流程图展现系统的控制流。

2.数据流图的处理过程可并行；系统流程图在某个时间点只能处于一个处理过程。



**2.活动图和状态图的区别**

状态图侧重于描述行为的结果，活动图侧重于描述行为的动作。

活动图可描述并发行为，而状态图不能。



**3.介绍对象模型、动态模型、功能模型，并详细说明它们之间的关联关系**

对象模型描述系统的静态结构，一般使用对象图来建模；

动态模型描述系统的交互次序，一般使用状态图来建模；

功能模型描述系统的数据变换，一般使用数据流图来建模。

关联关系：

对象模型描述了动态模型和功能模型所操作的数据结构，对象模型中的操作对应于动态模型的事件和功能模型中的函数。



**4.非功能性需求主要有四类：操作性需求、性能需求、安全性需求、文化需求。简要说明四类需求的含义。**

性能需求：指响应时间、吞吐量、资源利用率等与系统效率相关的指标。可靠性、可用性等指标可归为此类。

安全性需求：系统向合法用户提供服务并阻止非法用户使用服务。

操作性需求：与用户操作使用系统相关的一些需求。

文化需求：带有文化背景的系统需求。



**5.胖客户端和瘦客户端**

胖客户端和瘦客户端是相对的，之间的区别在于是否有大量的业务逻辑需要放在客户端。

c/s结构中，主要的逻辑程序放在客户端，很多时候服务器是指的数据库服务器，所以是胖客户端。

而在b/s结构中业务逻辑都放在服务器上，客户端只有个浏览器，服务器发送给客户端的只有遵循了html规则的字符串，这是瘦客户端。



胖客户端：要处理大量业务逻辑的；

瘦客户端：逻辑处理不放在客户端，客户端只做简单的数据校验等处理操作。



**6.信息工程方法中的“实体(Entity)”与面向对象方法中的"类(class)"之间有哪些不同之处？**

类用于面向对象建模，有属性和操作。

而实体用于数据建模，只有属性。



**7.EssentialUseCases和RealUseCases有哪些区别？**

EssentialUseCases 基本用例，RealUseCases 真实用例。

基本用例描述系统的基本功能，系统要实现的功能。

真实用例指的是实际环境中使用的场景和具体情况。

前者关注系统基本功能，后者关注系统在实际应用中的表现和满足需求的能力。



**8.协作图与顺序图存在哪些区别？**

顺序图强调消息的时间顺序，协作图强调消息的收发关系。



## 数据库设计

数据库设计关注的问题：性能、数据一致性、安全

### 规范化与反规范化

### 数据库设计过程

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\数据库设计过程.png)

逻辑建模：主要构造实体联系图，表达实体及其属性和实体间的联系。

物理建模：根据所选数据库系统设计数据库模式。



超实体：将多个实体中相同的属性组合起来构造出的新实体。

例如收件人和寄件人都包含相同的属性，可以设计出一个超实体“用户”来实现通用属性的抽象表示。



派生属性：指某个实体的非主键属性可以通过其他非主键属性决定。

### 规范化-范式

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\范式.png)

范式级别提升带来了什么负面影响？

数据库规范化的过程，实际上是对数据表的不断拆分，以达到更高的规范化程度。这样处理带来的问题是：系统大量查询不能通过单表来完成，而是需要将多表进行连接查询，所以表拆分的越多，查询性能也就越差。



### 反规范化

**优缺点**

规范化设计后，数据库设计者希望牺牲部分规范化来提高性能，这种规范化设计的回退方法称为反规范化。

优点：提高统计、查询效率

缺点：增加了数据冗余，浪费存储空间。增删改的效率降低，可能导致数据不一致，可能产生添加、修改、删除异常。

反规范化缺点

* 数据冗余
* 插入异常
* 删除异常
* 修改异常

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\反规范化缺点.png)



**反规范化技术**

(1)增加冗余列：通过增加数据冗余减少或避免查询时的连接操作。

(2)增加派生列：在表中可以增加由本表或其他表中数据计算生成的列，减少查询时的连接操作并避免计算或使用集合。

(3)表水平分割：把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立。缺点：如果要对所有表统计时，要拉去所有表的数据，会造成较大的网络传输。

(4)表垂直分割：对表进行分割，将主键与部分列放到一个表中，主键与其他列放到另一个表中，查询时减少I/O次数。

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\反规范化.png)





### 索引

提高查询效率，但降低了增加、修改、删除的效率，并且索引占用存储空间；B树和B+树；



索引采用B+树的原因：

1. 全部遍历，时间复杂度为O(n)
2. hash：优点：增删改查为O(1),只支持精确查找，缺点：不支持范围查询
3. 二叉查找树：优点:O(log2(n))，查找次数为树的高度。缺点：如果二叉查找树变成线性结构，时间复杂度为O(n)
4. 平衡二叉树：数据量越大导致树越高，树高问题导致磁盘I/O过多
5. B树：优点：每个节点可以有多个子节点，可以控制树的高度，比二叉平衡树减少磁盘I/O次数。缺点：数据库索引是存储在磁盘上的，它的所有节点都存放着索引和数据，它一次性读入内存需要查找的关键字也就越少，当加载索引的时候，需要加载更多的磁盘页，加大磁盘I/O的次数。
6. B+树：只有最底层的叶子节点（文件）保存数据，非叶子节点只保存索引，不保存实际的数据，那它一次性读入内存需要查找的关键字也就越多，磁盘I/O次数降低。并且它的查询也更加稳定，所以任何关键字的查找必须从根结点到叶子结点。而且B+树的叶子节点组成了一个链表，方便遍历查询。

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\B+树索引.png)

### 视图

并不在数据库中实际存在，而是一种虚拟的表

优点：

1.视图能**简化**用户的**操作**。（建立了视图，把视图当成表来用，背后的操作可以不管）

2.视图机制可以使用户以不同的方式查询同一数据。（可以查表，也可以查视图）

3.视图对数据库重构提供了一定程度的**逻辑独立性**。（表结构改了，视图可以不用改）

4.视图可以对机密数据提供**安全保护**。（可以把表的一部分数据授权）



视图是通过SQL语句得来的，效率是不高的，为了提高效率，可以使用物化视图。

物化视图：将视图的内容物理存储起来，其数据随原始表变化，同步更新。



数据库的多层级模式：

物理层次的存储、逻辑层次的表、最上层的视图



### 数据不一致问题

数据存了多份，存在了不同的地方，一份数据是不可能出现数据不一致问题的。

解决办法：

- 应用程序
- 触发器
- 物化视图



### 分区分表分库

能从整体去提升性能，但会提高复杂度

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\分区分表分库.png)

**分区和分表的区别**

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\分区和分表的区别.png)



**分区方式**

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\分区常见方式.png)

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\分区方式.png)



**分区优点：**

1.相对于单个文件系统或硬盘，分区可以存储更多的数据

2.数据管理方便。比如要清理或者废弃某年的数据，可直接删除该日期的分区数据

3.精准定位分区查询数据，不需要全表扫描，大大提高数据库检索效率

4.可跨多个分区磁盘查询，来提高查询的吞吐量

5.在涉及聚合函数查询时，可以很容易进行数据的合并



### 分布式数据库系统

主要考查点：

分布透明性

* 分片透明：分不分片用户感受不到
  * 水平分片：按行(记录)分
  * 垂直分片：按列(字段)分
* 位置分片：数据存在哪里，用户不用管



### NoSQL

两者对比

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\NoSQL对比.png)



NoSQL分类

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\NoSQL分类.png)

### 联邦数据库系统

联邦数据库类似于接口，对外提供统一的数据，做集成。

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\联邦数据库系统.png)



### 数据库性能优化

![](D:\github\MyKnowledgeRepository\img\ruankao\数据库\数据库性能优化.png)

**sql优化**

sql语句设计时，影响查询效率的设计原则：

1.查询时尽量不要返回不需要的行、列

2.进行多表查询时，尽量使用连接查询，避免使用子查询

3.尽量避免采用not in、not exist、like等使用全表查询的操作

4.尽量避免使用distinct关键字



### 真题

**1.逻辑数据模型设计过程包含哪些任务？**

- 构建系统上下文数据模型，包含实体及实体之间的联系；
- 绘制基于主键的数据模型，为每个实体添加主键属性；
- 构建全属性数据模型，为每个实体添加非主键属性；
- 利用规范化技术建立系统规范化数据模型。



**2.什么是超实体？什么是派生属性？**

超实体：将多个实体中相同的属性组合起来构造出的新实体。

例如收件人和寄件人都包含相同的属性，可以设计出一个超实体“用户”来实现通用属性的抽象表示。

派生属性：指某个实体的非主键属性可以通过其他非主键属性决定。

例如包裹单中的总计是由资费、挂号费、保价费、回执费计算得出，所以是派生属性。



**3.反规范化设计方法**

1. 增加冗余列（复制某一列数据）
2. 增加派生列（计算总和、平均值）
3. 表合并（把部分来自不同表的常用列合并成新表）
4. 表分割（把数据拆分为常用和不常用）



**4.解决数据不一致的三种常见方法**

1. 使用应用程序同步的方式
2. 使用触发器
3. 采用物化视图方式



**5.Redis和MySQL数据实时同步问题的常见方案：**

1. 同步双写。对数据库进行操作时，同步添加、修改或删除缓存数据。
2. 缓存补偿。在对数据进行查询时如果发现缓存数据不存在，则查数据库，并将数据同步至缓存中，实现缓存数据的补偿。
3. 主动同步。启动额外的服务区读取数据库binlog文件，通过解析binlog文件来确定数据库发生了什么更改从而更新redis。



## 架构设计

### 架构风格

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\架构风格.png)



### 软件架构评估-质量属性

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\架构评估-质量属性.png)

敏感点：为了实现某种特定的质量属性，一个或多个构件的特性。

权衡点：影响多个**质量属性**的特性，是多个质量属性的敏感点。通常权衡安全性和性能这两个质量属性。

风险点：架构设计中潜在的、存在问题的架构决策所带来的隐患。

非风险点：不会带来隐患，一般以“xx要求是可以实现或可接受的”方式表达。



### Web架构

考查点：**高性能**、高可用、可维护、可应变、安全性

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\Web架构.png)

#### web发展历程

##### 1.单台机器到数据库与web服务器分离

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\数据web分离.png)

##### 2.应用服务器集群

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\应用集群.png)

##### 3.负载均衡引入

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\负载均衡引入.png)

##### 4.Session共享机制

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\负载均衡+session共享.png)

##### 5.读写分离

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\数据库读写分离.png)

##### 6.缓存引入

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\缓存技术.png)

#### 集群、负载均衡

集群的引入会带来的问题：

1.用户请求由谁来转发给具体的应用服务器？（负载均衡）

2.用户每次访问的服务器不一样，那么如何维护session一致性问题？（有状态、无状态问题） 





**负载均衡技术**

* 应用层

  * HTTP重定向

    HTTP重定向就是应用层的请求转发。用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向，再次请求真正的集群。

    特点：实现简单（只需要一个跳转指令），但性能较差（越高层效率越低）。

  * 反向代理 

    在用户请求到达反向代理服务器时，由反向代理服务器根据算法转发到具体的服务器。常用nginx作为反向代理服务器

    特点：部署简单，但代理服务器可能成为性能瓶颈。

* 传输层

  * 基于DNS的负载均衡

    DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。

    特点：效率比HTTP重定向高，减少维护负载均衡服务器的成本。但一个应用服务器故障，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理。

  * 基于NAT的负载均衡

    将一个外部的IP地址映射为多个IP地址，对每次连接请求动态地转换为一个内部节点的地址。

    特点：技术较为成熟，一般在网关位置，可以通过硬件实现。像四层交换机一般采用这样的技术



**均衡算法**

* 静态算法（不考虑动态负载）
  * 轮转算法：轮流将服务请求调度给不同的节点
  * 加权轮转算法：考虑不同节点处理能力的差异
  * 源地址哈希散列算法：根据请求的源IP地址，作为散列键从静态分配的散列表找出节点。
  * 目标地址哈希散列算法：根据请求的目标的IP地址进行散列
  * 随机算法：随机分配，简单，但不可控
* 动态算法
  * 最小连接数算法：新请求分配给当前活动请求数量最少的节点，每个节点处理能力相同的情况下。



硬件负载均衡：F5

软件负载均衡：Ngnix、LVS



**有状态和无状态**

无状态服务：对单次请求不依赖于其他请求，即处理一次请求所需要的全部信息，服务器本身不存储任何信息。

有状态服务：会在自身保存一些数据，先后的请求是有关联的。



#### 数据持久化

**ORM**

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\ORM.png)

**Hibernate架构图**

![](D:\Github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\Hibernate架构图.png)

#### 读写分离

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\数据库读写分离.png)

主从复制机制的好处：

1.安全性。数据冗余备份，不会因为机器故障导致数据丢失。

2.提升性能。不同用户的请求可以从不同的数据库读取数据，提高并发度。

3.提升可用性。一台服务器故障不影响整个系统正常运作。

4.提升扩展性。当性能碰到瓶颈时，可通过扩展服务器的方式满足要求。

#### 缓存

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\缓存技术.png)



##### 缓存与数据库的协作（Redis与关系数据库同步方案）

（一）读取操作

1.根据key从缓存中读取

2.若缓存中没有，则根据key在数据库中查找

3.读取到值之后更新缓存

（二）数据写入

1.根据key值写入数据库

2.根据key更新缓存



**Redis和MySQL数据实时同步问题的常见方案：**

1. 同步双写。对数据库进行操作时，同步添加、修改或删除缓存数据。
2. 缓存补偿。在对数据进行查询时如果发现缓存数据不存在，则查数据库，并将数据同步至缓存中，实现缓存数据的补偿。
3. 主动同步。启动额外的服务区读取数据库binlog文件，通过解析binlog文件来确定数据库发生了什么更改从而更新redis。

**数据实时同步更新和数据异步准实时更新**

同步：更新数据时在同一事务内依次完成删除缓存，更新数据库，再写入缓存

异步：更新数据时在同一事务内首先通过消息队列发布待更新的消息给缓存更新服务，再更新数据库；缓存更新服务订阅消息队列，待收到更新事件执行缓存更新。

项目数据量极大，且性能要求高，适合采用异步的方案。



##### Redis和Mecache比较

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\Mecache和Redis比较.png)

MemCache存在数据可靠性和一致性的问题，原因是：

(1)MemCache没有持久化功能，所以断电数据会全部丢失，而且无法恢复，这存在可靠性问题。

(2)MemCache不支持事务，所以操作过程中可能产生数据的不一致性。



##### Redis集群切片

集群切片的基本思想：Redis不止一台服务器，可能有多台，那数据到底存在哪台服务器？

集群切片有：

1.客户端分片，即在客户端就通过key的hash值对应到不同的服务器。

2.对数据根据key散列在不同的slot上，不同的slot对应不同的服务器。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\Redis集群切片.png)



redis数据分片方案

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\redis数据分片方案.png)

一致性哈希算法建立了一个圆圈机制，把服务器和哈希值都描绘在圆圈上面，然后根据圆圈顺时针方向找到哪一台服务器，就把数据存在哪一台服务器上面，建立了一种动态规则。（适合新增服务器）



一致性哈希算法的优点：

1. 可扩展性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销。
2. 更好地适应数据的快速增长。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\redis分片方案1.png)



##### Redis分布式存储

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\Redis分布式存储方案.png)



##### redis数据类型

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\redis数据类型.png)



##### redis淘汰策略

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\redis淘汰策略.png)

##### redis持久化

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\redis持久化.png)



##### 缓存常见问题

大部分情况下，加缓存的目的是：为了减轻数据库的压力，提升系统的性能。

[缓存踩过的7个坑](https://mp.weixin.qq.com/s/DsX9pCAlb9313Pmf2c_Y1g)

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\缓存雪崩.png)



![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\缓存穿透.png)



![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\缓存降低.png)



###### 缓存穿透

缓存穿透是指查询一个一定不存在的数据，比如id=-1，由于缓存命不中，就会去查询数据库，查询不到数据则不会写入缓存，这就导致了这个不存在的数据每次请求都要到数据库查询，一旦并发点高，就会造成缓存穿透。

![缓存穿透](D:\github\MyKnowledgeRepository\img\picture\缓存穿透.png)



**解决方案：**

1. 将空对象也缓存起来，并给它设置很短的时间，最长不超过5分钟
2. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被布隆过滤器拦截掉，从而避免对底层存储系统的查询压力。（官方回答：查询缓存之前，对key值进行过滤，只允许系统中存在的key进行后续操作，例如采用key的bitmap进行过滤）



这两种解决方案都存在问题：

1.将空值缓存起来，但是不在系统的key是无限的，如果均设置key为空，会造成内存资源的极大浪费，引起性能急剧下降。所以可以采用布隆过滤器的方式

2.使用布隆过滤器也存在一些问题，因为布隆过滤器存在误杀的情况，可能会把少部分正常用户的请求也过滤了。同时，如果有用户信息有变化，需要实时同步到布隆过滤器，不然会有问题。



布隆过滤器的原理：当一个元素加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，只要看看这些点是不是都是1就大概知道集合中有没有它，如果这些点有任何一个0，则被检索元素一定不在，如果都是1，则被检元素很可能在。

![布隆过滤器](https://ask.qcloudimg.com/http-save/yehe-1215148/3oexxelype.png)

优点：

1. 增加和查询的时间复杂度为O(K)，与数据量大小无关
2. 哈希函数相互之间没有关系，方便并行计算

缺点：

1. 有误判的概率
2. 一般不能从布隆过滤器中删除元素

###### 缓存雪崩

如果缓存集中在一段时间内失效，发生大量缓存穿透，所有查询都落到数据库上，就会造成缓存雪崩。

![缓存雪崩](D:\github\MyKnowledgeRepository\img\picture\缓存雪崩.png)

**解决方案：**

1.把每个key失效的时间加上一个随机值，尽量让失效的时间点分布在不同时间点上。

2.设置两级或多级缓存，避免访问数据库服务器。（此方式没有从根源上解决大量缓存key同时失效的问题）



**针对缓存服务器down机的情况，该怎么办？**

采用高可用架构，比如使用了redis，采用哨兵模式或者集群模式，避免单节点故障导致整个redis服务不可用的情况。使用哨兵模式之后，当某个master服务下线时，自动将该master下的某个slave服务升级为master服务，替代已下线的master服务继续处理请求。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibJZVicC7nz5iaclwm3x3ZdUQCuojmpqh5GcvF2zsgE4uO5bqc1kJ6LnZ7UwuGicvpetkpO4Q6I4G3czJaEWE8qcug/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**如果做了高可用架构，redis服务还是挂了，该如何解决？**

这时候就需要服务降级，我们需要配置一些默认的兜底数据。

程序中有一个全局开关，比如有10个请求最近一分钟内，从redis中获取数据失败，则全局开关打开。后面的新请求，直接从配置中心获取默认的数据。

同时还需要个job，定期从redis中获取数据，如果在最近一分钟内可以获取到两个数据，则把全局开关关闭。后面的请求，又可以正常从redis中获取数据了。



**服务降级和服务熔断**

- 服务降级

  - 概念：服务降级一般是指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而释放服务器资源的资源以保证核心业务的正常高效运行。
  - 原因：服务器的资源是有限的，而请求是无限的。在用户使用即并发高峰期，会影响整体服务的性能，严重的话会导致宕机，以至于某些重要服务不可用。故高峰期为了保证核心功能服务的可用性，就需要对某些服务降级处理。可以理解为舍小保大。
  - 服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。

- 服务熔断

  - 概念：应对微服务雪崩效应的一种链路保护机制，类似股市、保险丝。

  - 原因：微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务c，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应

  - 服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。

    

###### 缓存击穿

是指一个key非常热点，在不停地扛着大并发，当这个key失效时，持续的大并发量穿透缓存，直接请求数据库。就像一个屏障凿开了一个洞

![](https://mmbiz.qpic.cn/sz_mmbiz_png/ibJZVicC7nz5iaclwm3x3ZdUQCuojmpqh5GyzWVL4S1Wc6iajz9bd2mLFI62HwqYkTpbibibotcwwhWAygauq4cEWpicg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**解决方案：**

1.设置Key永不过时

2.自动续期。启动一个job给指定的key自动续期，比如每隔20分钟执行一次自动更新缓存。

3.加锁，防止多个相同的请求同时访问数据库。



###### 数据不一致

不管是先写数据库，再写缓存，还是先写缓存再写数据库，都会出现双写不一致的问题。

在写数据库时，缓存写成功了，数据库写失败，或者反之，从而造成数据不一致的问题。在高并发场景中，当多个请求发生时，也可能产生读写冲突的并发问题。

如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。

如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。

但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。

也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。

这就会出现：数据库是新数据，而缓存是旧数据，两边数据不一致的情况。



###### 大key问题

大key问题是指：缓存中单个key的value值过大。

解决方案：

1.缩减字段名，只保存需要用到的字段。

2.数据压缩。



###### 热key问题

比如你现在搞了一个促销活动，有几款商品性价比非常高，这些商品数据在Redis中按分片保存的，不同的数据保存在不同的服务器节点上。

如果用户疯狂抢购其中3款商品，而这3款商品正好保存在同一台Redis服务端节点。

这样会出现大量的用户请求集中访问同一天Redis服务器节点，该节点很有可能会因为扛不住这么大的压力，而直接down机。

解决方案：

拆分key。前做好评估，分析这些商品哪些是热点商品。然后将热点商品分开保存，不要集中保存到同一台Redis服务器节点。这样不同的Redis服务器节点，可以分摊一些用户的请求压力。



###### 命中率问题

1.缓存预热。在API服务启动之前，可以先用job，将相关数据先保存到缓存中，做预热。这样后面的用户请求，就能直接从缓存中获取数据，而无需访问数据库了。

2.合理调整过期时间。给缓存设置的过期时间太短，导致后面会产生大量的过期缓存。会导致缓存命中率非常低。

3.增加缓存内存。部署的Redis服务器的内存太小，很容易出现内存不足的情况，从而会频繁触发内存淘汰机制。也会影响缓存的命中率。



#### CDN（内容分发网络）

思想：建立镜像站点，当有访问请求时，以就近原则为访问。

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\CDN.png)

#### 响应式WEB设计

理念：创建页面的图片大小，可智能地根据用户行为以及使用的设备环境进行相应的布局。

方案：

1. 流式布局和弹性化设计：使用相对单位，使用百分比的方式
2. 响应式图片：不仅要同比缩小图片，还要在小的设备上降低图片自身的分辨率



#### 中台

SOA的架构思想从来没有过时，SOA里面强调的可复用、解耦、灵活的组装编排，在我们工作、技术产品实现很多场景里面都会出现和应用。中台的架构思想，核心就是共性的业务能力的下沉。在共性的业务能力下沉以后，上层的前台的业务应用可以基于共性可复用的能力，去灵活的复用和组装，快速地实现上层应用。这个思想和SOA架构思想是一致的，这是第一点。第二个点，共性能力下沉以后我们怎样去建设共性能力，是不是像传统的方式就建设一个大的单体来实现这个共性能力？实际上不是的，我们最好的方式是把这个共性的能力再做拆分，拆分成一个个更小的组件来去实现这些能力，而这个正好就是微服务的架构思想。所以SOA、中台、微服务这些都是有通用的思想去复用。

中台 = SOA思想  + 微服务

![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp1-tt.byteimg.com%2Forigin%2Fpgc-image%2Ff4d73047beaf464fad7bb32bbf9c26d6%3Ffrom%3Dpc&refer=http%3A%2F%2Fp1-tt.byteimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1669468977&t=247e52b61e3a8fbcb553f7a0fff6ec8b)

#### web系统分层

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\web系统分层.png)

J2EE核心组成：

容器：Applet Container、Application Container、Web Container、EJB Container

组件：Applet、Application、JSP/Servlet、EJB



EJB中的Bean分三种类型：Session Bean、Entity Beans和Message-Driven Bean。

Sesssion Bean：维护一个短暂的会话。

Entity Beans：维护一行持久稳固的数据

Message-Driven Bean：异步接受消息



MVC解释：

M：表示模型，处理数据逻辑部分

V：表示视图，处理数据展示部分

C：表示控制器，处理用户交互部分



胖客户端和瘦客户端是相对的，之间的区别在于是否有大量的业务逻辑需要放在客户端。

c/s结构中，主要的逻辑程序放在客户端，很多时候服务器是指的数据库服务器，所以是胖客户端。

而在b/s结构中业务逻辑都放在服务器上，客户端只有个浏览器，服务器发送给客户端的只有遵循了html规则的字符串，这是瘦客户端。



### 真题

**1.Redis和Memcache比较**

![](D:\github\MyKnowledgeRepository\img\ruankao\架构设计\Mecache和Redis比较.png)

MemCache存在数据可靠性和一致性的问题，原因是：

(1)MemCache没有持久化功能，所以断电数据会全部丢失，而且无法恢复，这存在可靠性问题。

(2)MemCache不支持事务，所以操作过程中可能产生数据的不一致性。



**2.Redis与关系数据库的同步方案**

（一）读取操作

1.根据key从缓存中读取

2.若缓存中没有，则根据key在数据库中查找

3.读取到值之后更新缓存

（二）数据写入

1.根据key值写入数据库

2.根据key更新缓存



**3.Redis分布式存储方案和Redis集群切片方式**

Redis分布式存储有主从模式、哨兵模式、集群模式。

集群切片有：

1.客户端分片，即在客户端就通过key的hash值对应到不同的服务器。

2.对数据根据key散列在不同的slot上，不同的slot对应不同的服务器。



**4.什么是面向服务架构(SOA)以及ESB在SOA中的作用与特点？**

SOA是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口联系起来。

接口是采用中立的方式定义，独立于实现服务的硬件平台、操作系统和编程语言。

这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。



ESB的作用与特点：

1、SOA的一种实现方式，ESB在面向服务的架构中起到总线作用，将各种服务进行连接和整合。

2、描述服务的元数据和服务注册管理。

3、在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力。

4、支持服务之间的动态交互，解耦服务请求者和服务提供者。



**5.基于SOA的银行信息系统架构设计**

UDDI用来注册和查询服务，发现服务的。

publish是发布服务，把服务发布到ESB总线上。

![](D:\Github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\SOA架构.png)



**6.列举3种实现信息系统安全保障的措施**

1、引入https协议或采用加密技术对数据先加密再传输

2、采用信息摘要技术对重要信息进行完整的验证

3、交易敏感信息采用数字签名机制



**7.架构设计图填空**

![](D:\Github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\架构设计图1.png)



**8.sql注入**

SQL注入攻击就是通过SQL命令插入到请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令

抵御SQL注入攻击：

1.使用参数化的过滤语句

2.检查用户输入的合法性

3.用户相关数据加密处理

4.存储过程来执行所有的查询



**9.仓库和管道过滤器架构风格对比**

![](D:\Github\MyKnowledgeRepository\img\ruankao\架构设计\仓库和管道架构风格对比.png)



**10.对比RDB和AOF两种持久方式**

磁盘更新频率：AOF比RDB文件更新频率高

数据安全：AOF比RDB更安全

数据一致性：RDB每隔一段时间存储，可能发生数据不一致；AOF通过append模式写文件，即使宕机，也可以通过redis-check-aof工具解决数据一致性问题

重启性能：RDB比AOF好

数据文件大小：AOF文件比RDB文件大。

如果考虑宕机情况下，需要最短时间内恢复服务，可以考虑选择RDB。



**11.缓存中存储当前的热点数据， Redis 为每个 KEY 值都设置了过期时间，以提高缓存命中率。为了清除非热点数据， Redis 选择“定期删除+惰性删除”策略。如果该策略失效， Redis 内存使用率会越来越高，一般应采用内存淘汰机制来解决。 请用 100 字以内的文字简要描述该策略的失效场景，并给出三种内存淘汰机制。**

失效场景：如果“定期删除”没删除key，也没有及时去请求key，也就是“惰性删除”也没生效，这样Redis默认的"定期删除+惰性删除"策略就失效了。

淘汰机制：

- 从已设置过期时间的数据集，采用最近最少使用的淘汰机制
- 从已设置过期时间的数据集，采用将要过期的淘汰机制
- 从已设置过期时间的数据集，采用任意选择的淘汰机制
- 从数据集中采用最近最少使用的淘汰机制
- 从数据集中采用任意选择的淘汰机制



**12.采用标准的数据访问机制的原因？**

标准的数据访问机制可以在硬件供应商和软件开发商之间建立一套完整的规则。只要遵循这套规则，数据交互对两者来说是透明的，硬件供应商只需要考虑应用程序的多种需求和传输协议，软件开发商也不必了解硬件的实质和操作过程，实现对设备数据的统一管理。



**13.SSM框架填空**

![](D:\Github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\SSM框架.png)





**14.云平台架构**

![](D:\Github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\云平台.png)



**15.描述云平台在网关管理、数据处理和系统性能方面的特点**

网关管理：云平台更强，可以实现远程网关管理，可以对不同地点的多种设备进行统一管理，管理能力更强。

数据处理：数据一般经由网关传递到云上数据库中，再进行处理，这样对数据分析、挖掘更有利，同时存储在云端，数据更安全，有容灾能力。

系统性能：数据存在云上数据库中，通信效率更高，同时云也有更强的数据处理能力，所有更高效。



**16.从数据传输可靠性的角度对比分析TCP和UDP通信协议的不同**

TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP 之所以可靠，是因 为建立连接时有 3 次握手，通信时有回应机制，所以丢了包，能重传以保障通信可靠性。

UDP 是一种面向无连接的传输层通信协议，丢了包不会重传，所以不能保障通信可靠性。



**17.JWT**

JWT由三部分组成:头部、载荷和签名。

头部包含令牌类型和所使用的算法。

载荷包含用户信息和其他元数据。

签名用于验证令牌的完整性和真实性。



JWT的优势在于：

- 无状态性：服务器无需存储会话信息，降低了服务器负担。
- 自包含：所有必要信息直接包含在 JWT 中，便于跨域传输。
- 安全性：通过签名机制确保数据的完整性和防篡改。



JWT 通过其内置的签名机制来防止数据被篡改，确保消息的完整性和真实性。JWT 的结构分为三部分：Header、Payload 和 Signature。签名部分正是 JWT 防止篡改的关键所在，其生成和验证流程如下：

签名生成过程

1. **Header 和 Payload 编码**：首先，JWT 的 Header 和 Payload 分别被 Base64Url 编码，形成两段字符串。Header 包含了关于 JWT 的元数据，如签名算法类型；Payload 则包含了实际要传输的数据，如用户标识、过期时间等。
2. **签名数据准备**：将编码后的 Header 和 Payload 通过 `.` 连接起来形成一个字符串，这个字符串与用于签名的密钥（可以是对称密钥或私钥，依据所选签名算法而定）一起作为签名的输入。
3. **签名计算**：根据 Header 中声明的签名算法（如 HMAC SHA256、RSA、ECDSA 等），使用密钥对上述拼接的字符串进行加密计算，产生一个签名字符串。
4. **组合 JWT**：最后，将 Base64Url 编码的 Header、Payload 和新产生的 Signature 通过 `.` 连接，形成完整的 JWT 字符串。

防篡改验证过程

1. **接收 JWT**：接收方首先解析 JWT，将其分割成 Header、Payload 和 Signature 三部分。
2. **签名验证**：再次对 Header 和 Payload 进行 Base64Url 解码，并使用声明的签名算法和相应的密钥（如果是对称加密，则与签名时使用的密钥相同；如果是非对称加密，则使用与私钥配对的公钥）对这两部分数据进行计算，生成一个新的签名字符串。
3. **比较签名**：将新生成的签名与 JWT 中携带的原始 Signature 进行对比。如果两者完全一致，则说明在传输过程中 JWT 没有被篡改，其内容是完整且真实的；若不一致，则表明 JWT 可能被篡改或不是由预期的发送方发出。



**18.SpringCloud架构**

![](D:\Github\MyKnowledgeRepository\img\ruankao\架构设计\web架构\SpringCloud架构.png)



## 大数据

### Lambda架构和Kappa架构

#### 架构组成

Lambda架构由三层组成：批处理层、速度处理层、服务层

- 批处理层存储管理主数据集和预先批处理计算好的视图

- 速度处理层会实时处理新来的大数据。（本质上速度层弥补了批处理层所导致的数据视图滞后，

  比如说，批处理层的每个任务都需要 1 个小时才能完成，而在这 1 个小时里，我们是无法获取批处理层中最新任务给出的数据视图的。

  而速度层因为能够实时处理数据给出结果，就弥补了这 1 个小时的滞后。）

- 服务层，所有批处理层和速度层处理完的结果都会输出存储到服务层中，服务层通过返回预先计算的数据视图或速度层处理构建好数据视图来响应查询。



Kappa架构包含两层：流式处理层、服务层

- 流式处理层：通过流式处理系统接收所有数据，并进行实时计算，更新存储中的结果视图。
- 服务层：对外提供查询服务，直接基于流式处理层更新的结果视图进行查询返回。

![](D:\Github\MyKnowledgeRepository\img\ruankao\大数据\批处理和实时处理.png)

#### 架构对比

![](D:\Github\MyKnowledgeRepository\img\ruankao\大数据\Lambda架构和Kappa架构对比.png)



#### Kappa-Lambda架构

Kappa-Lambda架构是在Kappa架构的基础上，引入了Lambda架构中的批处理层组件，形成的一种混合架构。

架构组件：

- Stream层：实时流式处理层
- Serving层：查询服务层
- Batch层：批处理层，用于复杂的历史数据分析
- Speed层：速度层，用于低延迟的实时计算



工作流程：

1. Stream层接收实时数据，进行实时计算
2. Speed层从Stream层获取实时结果，进行低延迟的实时分析
3. Serving层查询时，实时部分从Speed层获取，历史部分从Batch层获取
4. Batch定期从Stream层获取数据，进行复杂的历史数据分析和处理



Kappa-Lambda架构相比Kappa架构，引入了批处理层组件，以便进行复杂的历史数据分析。同时保留了Speed层，进行低延迟的实时计算

![](https://img-blog.csdnimg.cn/67f33aac3ee64433abe3c6b00e4fcf38.png)

### 数据湖、湖仓一体

数据湖的核心是开放性，里面是无序的数据，什么数据都存。结构化的、非结构化的、半结构化的、二进制等数据。

需要两个特点：架构存储足够强大、数据处理足够牛逼。

架构存储强大指存得下、放得久。数据处理牛逼指放的时候和取的时候足够丝滑。



湖仓一体可以理解为把数据湖这个大杂间区分很多区，每个区是一个应用站点，有的站点做BI、有的站点做大数据处理、有的站点做机器学习

湖仓一体架构就是把数据湖作为中央存储库，围绕数据湖建立各种服务的站点，比如数据仓库，供业务分析和接入BI使用；再比如供机器学习用的站点；供大数据处理的站点，最终实现随心所欲使用数据湖中的数据。



**数据湖和数据仓库的区别**

![](D:\Github\MyKnowledgeRepository\img\ruankao\大数据\数据湖和数据仓库的区别.png)





# 论文写作

## 论文写作四部曲

1. 找准核心论点（5分钟）
2. 搭建论文框架（10分钟）
3. 撰写摘要（15分钟）
4. 正文写作（90分钟）



## 论文框架

![](D:\github\MyKnowledgeRepository\img\ruankao\论文\论文框架1.png)





## 撰写摘要

![](D:\github\MyKnowledgeRepository\img\ruankao\论文\撰写摘要.png)



建议第三个模板，比较常规。

![](D:\github\MyKnowledgeRepository\img\ruankao\论文\摘要模板.png)



## 加分与扣分

![](D:\github\MyKnowledgeRepository\img\ruankao\论文\加分扣分准则.png)



## 历年真题

![](D:\Github\MyKnowledgeRepository\img\ruankao\论文\历年真题.png)



## 论文模板

**摘要**

​	2019年4月，我参加国内某一线互联网大厂的直播数据中台项目的开发。该平台解决了集团下各个app等直播模块数据孤岛问题，通过数据中台统一服务的方式解决能力横向复用难、重复造轮子的问题，带来的收益是1.补齐了直播业务缺失的数据统计能力；2.统一维护，减少了维护成本；3.只要是接入中台的产品，能快速应用一套统计体系。我作为该项目的架构师和主要负责人，主要完成了需求分析、系统架构分析和设计等工作。通过团队一整年的努力，平台开发完成并顺利上线，整个系统已经稳定运行3年了，顺利达到了既定目标。本文作者结合实际经验，以该项目为例，讨论...**(主题)**，包括...**(过程、方法、措施)**。



**正文**

​	2019年以前，集团下的各个app都有直播模块，各app的直播是各团队自己迭代维护的，业务团队独立、研发团队独立、数据团队逻辑上也是独立。这带来了以下问题：1.能力横向复用难，重复造轮子问题。例如，一个功能、一套方法论，在某app端验证效果好，想要移植到另一个app，需要重新开发，这也带来了重复造轮子的问题。2.因为重复造轮子，也就造成了产品、研发、运营人力和成本的浪费。3.同时会造成对外品牌认知不统一，品牌效应难以拓展延申的问题。正是在这一背景下，集团提出建设直播数据中台，该项目既补齐了直播业务缺失的数据统计能力，比如，口径统一，对齐了各产品的数据口径，减少了沟通成本，同时统一了维护，减少了维护成本。只要是接入中台的产品，能快速应用一套统计体系。**（开头项目背景介绍）**

​	**回答问题二，介绍相关的技术点（理论部分）**

​	...

​	...

​	**结合项目实际情况进行分析（实践部分）**

​	...

​	...

​	经过我和团队的不懈努力，历时一年多，项目于2020年7月上线，整个系统运行稳定，达到了预期的目标和要求，提高了集团的业务处理的效率，创造了极大的价值。但是，在实施过程中也存在一些问题，由于数据中台里面存在很多大数据任务，如果大数据任务不分优先级同时在跑，那计算资源很快就会变得特别紧张，导致核心任务不能及时跑完，因此需要建立具有动态优先级调整机制的处理队列，让核心任务优先使用计算资源。我们也已经把这些经验和教训以文档的方式记录下来，供其他技术人员学习，为今后系统架构设计提供帮助。



## 自己的论文

### 架构风格

**摘要**

​	2019年4月，我参加国内某一线互联网大厂的直播数据中台项目的开发。该平台解决了集团下各个app等直播模块数据孤岛问题，通过数据中台统一服务的方式解决能力横向复用难、重复造轮子的问题，带来的收益是补齐了直播业务缺失的数据统计能力；减少了维护成本；接入中台的产品，能快速应用一套统计体系。我作为该项目的架构师和主要负责人，主要负责设计平台系统架构。通过团队一整年的努力，平台顺利完成开发和上线，整个系统已经稳定运行2年了，顺利达到了既定目标。本文作者结合实际经验，以该项目为例，讨论几种常用软件架构风格及特点，然后结合本次项目采用的数据流风格、虚拟机风格以及仓库风格，论述该项目在软件架构选择过程中，为何选择这三种风格组合，最后总结项目中所遇到的问题。

**正文**

```text
	2019年以前，集团下的各个app都有直播模块，各app的直播是各团队自己迭代维护的，业务团队独立、研发团队独立、数据团队逻辑上也是独立。这带来了以下问题：1.能力横向复用难，重复造轮子问题。例如，一个功能、一套方法论，在某app端验证效果好，想要移植到另一个app，需要重新开发，这也带来了重复造轮子的问题。2.因为重复造轮子，也就造成了产品、研发、运营人力和成本的浪费。3.同时会造成对外品牌认知不统一，品牌效应难以拓展延申的问题。正是在这一背景下，集团提出建设直播数据中台，该项目既补齐了直播业务缺失的数据统计能力，比如，口径统一，对齐了各产品的数据口径，减少了沟通成本，同时统一了维护，减少了维护成本。只要是接入中台的产品，能快速应用一套统计体系。
	常见的五种架构风格有数据流风格、调用返回风格、独立构件风格、虚拟机风格以及仓库风格，接下来会对这五种架构进行具体介绍和分析。
	数据流风格包括批处理序列架构风格和管道-过滤架构风格。1.批处理序列架构风格，组件是一系列固定顺序的计算单元，组件间只能通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在前一步结束后才开始，数据必须是完整的，以整体的方式传递。2.管道过滤风格中每一个构件都有一组输入和输出，构件读取输入的数据流，经内部处理，然后产生输出数据流。
	调用返回风格包括层次结构架构风格、面向对象架构风格和主程序子程序架构风格。1.层次结构架构风格中，层次系统组织成一个层次结构。这个风格的特点是每层为上一层提供服务，同时使用下一层服务，只能见到与自己邻接的层。大的问题分解为若干个渐进的小问题，逐步解决，隐藏了很多复杂度。每修改一层，最多影响邻接层。上层必须知道下层的身份，不能调整层次间的顺序。2.面向对象风格是将数据的表示方法和对应的操作方法封装在一个对象中，对象和对象之间是通过函数和过程调用来交互。这种风格的构件就是对象，连接件就是函数和过程调用。这种结构风格中包含有封装、交互、多态、集成和重用等特征。 3.主程序子程序架构风格是面向过程的，把问题划分为若干个处理步骤，构件即为主程序和子程序。子程序通常可合成为模块，过程调用充当连接件作为交互机制，调用关系就有层次性。
	独立构件风格包括进程通信架构风格和事件驱动架构风格。1.进程通信架构风格中，构件是独立的进程，连接件是消息传递，这种风格的特点是构件通常是命名过程，消息传递的方式可以是点到点，异步和同步方式以及远程过程调用等。2.事件驱动架构风格中，构件不直接调用一个过程，而是触发或广播一个或多个事件，系统中其他构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程。
	虚拟机风格包括解释器风格和基于规则的系统架构风格。1.解释器架构风格中一个解释器通常包括完成解释工作的解释引擎，一个将被解释的代码的存储区，一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程。2.基于规则的系统包括规则集、规则解释器、规则数据选择器及工作内存。
	仓库风格包括数据库架构风格和黑板架构风格。1.数据库架构风格中构件主要有两大类，一个是中央共享数据源，保存当前系统的数据状态；另一个是多个独立处理元素，处理元素对数据元素进行操作。2.黑板架构风格包括知识源、黑板和控制3个部分。知识源包括若干个独立计算的不同单元，提供解决问题的知识，响应黑板上的变化。黑板是一个全局数据库，包含解域的全部状态，是知识源互相作用的唯一媒介。黑板通常应用在对于解决问题中没有确定性算法的系统中，例如语音识别、模式识别、图像处理以及知识推理等。
	首先本次项目的用户使用界面采用的是B/S架构系统，直播数据中台还需要数据仓库提供相关业务指标数据，并采用微服务架构与多个app系统进行交互。在架构风格上，最终选择管道过滤器风格、分层架构风格、进程通信架构风格、基于规则的系统架构和数据库系统几个架构风格进行混合使用。下面讲述选择这几种架构风格的原因。
	选择管道过滤器架构风格和进程通信架构风格是因为中台涉及到直播数据指标需要由数据仓库提供，通过自建的ETL中间件每日从仓库中抽取数据，通过转换任务进行逻辑处理，每个转换都有一个输入流和输出流，许多转换任务一起构成了一个完整的数据处理流程。直播数据中台需要与不同的app系统的数据进行密切交互，涉及到异构系统之间的通信，业务模块通过远程调用其他服务和点到点异步消息通讯。
	选择分层架构风格和数据库系统架构风格是因为用户使用平台时使用的是B/S架构，具有N层架构的特点，采用表示层、逻辑处理层和数据持久层的方式，每一层只为上一层提供服务，是典型的分层架构。数据持久层保存的数据、ETL抽取的数据以及Spark任务处理的数据都保存到Hive数据仓库中，逻辑层处理涉及的操作都与中央的数据仓库交互，完成对数据的读取、处理和存储等操作。
	选择解释器的系统架构风格是由于大数据处理Spark经常要编写很长一段scala代码去处理数据，对大数据处理开发人员要求比较高，开发也比较难，因此平台推出sql化的标准统一服务。开发人员只需要写spark sql代码即可，由底层的相应模块去解释执行sql代码，翻译为相应的Spark RDD的任务去执行处理。这种解释器的系统架构风格大大提高了数据开发人员的效率，使数据开发人员更加专注于业务的处理，而不需要花费太多地精力去研究技术。
	经过我和团队的不懈努力，历时一年多，项目于2020年7月上线，整个系统运行稳定，达到了预期的目标和要求，提高了集团的业务处理的效率，创造了极大的价值。但是，在实施过程中也存在一些问题，由于数据中台里面存在很多大数据任务，如果大数据任务不分优先级同时在跑，那计算资源很快就会变得特别紧张，导致核心任务不能及时跑完，因此需要建立具有动态优先级调整机制的处理队列，让核心任务优先使用计算资源。我们也已经把这些经验和教训以文档的方式记录下来，供其他技术人员学习，为今后系统架构设计提供帮助。
```

### 架构评估

**摘要**

​	2019年4月，我参加国内某一线互联网大厂的直播数据中台项目的开发。该平台解决了集团下各个app等直播模块数据孤岛问题，通过数据中台统一服务的方式解决能力横向复用难、重复造轮子的问题，带来的收益是补齐了直播业务缺失的数据统计能力；减少了维护成本；只要是接入中台的产品，能快速应用一套统计体系。我作为该项目的架构师和主要负责人，主要负责设计平台系统架构。通过团队一整年的努力，平台顺利完成开发和上线，整个系统已经稳定运行3年了，顺利达到了既定目标。本文作者结合实际经验，以该项目为例，讨论软件架构评估所普遍关注的质量属性并阐述其具体含义，然后详细介绍本次软件架构评估采用的ATAM方法、实施过程，评估小组经过对系统中的风险点、敏感点、权衡点分析后生成质量效用树。

**正文**

```text
	2019年以前，集团下的各个app都有直播模块，各app的直播是各团队自己迭代维护的，业务团队独立、研发团队独立、数据团队逻辑上也是独立。这带来了以下问题：1.能力横向复用难，重复造轮子问题。例如，一个功能、一套方法论，在某app端验证效果好，想要移植到另一个app，需要重新开发，这也带来了重复造轮子的问题。2.因为重复造轮子，也就造成了产品、研发、运营人力和成本的浪费。3.同时会造成对外品牌认知不统一，品牌效应难以拓展延申的问题。正是在这一背景下，集团提出建设直播数据中台，该项目既补齐了直播业务缺失的数据统计能力，比如，口径统一，对齐了各产品的数据口径，减少了沟通成本，同时统一了维护，减少了维护成本。只要是接入中台的产品，能快速应用一套统计体系。
	软件质量属性是软件架构设计时关注的一个重点，在软件架构评估中质量属性包括性能、可用性、安全性、可修改性、可靠性、易用性等。其中前4个质量属性是质量效用树的重要组成部分。具体含义：
    (1)性能是指系统响应能力，即系统多久才能对某个事件做出响应，或在某段时间内能处理事件的个数；
    (2)可用性是指系统能正常运行的时间比例；
    (3)安全性是指系统除了能够为合法用户提供服务的同时还能阻止非授权用户使用的企图或拒绝服务的能力；
    (4)可修改性是指能快速地并以较高性价比对系统进行变更的能力；
    (5)可靠性是指软件系统在应用或错误面前，在意外或错误使用情况下维持系统的功能特性的基本能力。
    (6)易用性是衡量一个用户使用软件产品完成指定任务的难易程度。
	常用的架构评估方法有基于调查问卷的评估方式、基于度量的评估方式、基于场景的评估方式。基于问卷调查的方式具有主观性不太适合本项目。基于度量的评估方式虽然评价比较客观，但需要评价者对系统架构有精确地了解，所以也不太适合本项目。基于场景的评估方式要求评估者对系统有中等了解，评价偏主观一点，但适用于本项目，故采取基于场景的评估方式。基于场景的评估方式又分为软件架构分析方法SAAM、架构权衡分析方法ATAM，成本效益方法CBAM。本项目根据不同的质量属性使用了架构权衡分析方法ATAM作为系统架构评估的方法。
	在进行架构评估时，按照需求确定了评估参与者，评估小组有我的leader，leader+1，项目经理、开发人员、数据分析师、运营人员等组成。项目决策组成人员主要是leader、leader+1、集团中的首席架构师以及各方向的代表人员等。架构涉众包含开发人员、测试人员、运维人员等。架构评估经历了描述和介绍阶段、调查分析阶段、测试阶段和报告阶段等。下面我分别对这四个阶段进行介绍。
	描述和介绍阶段，由于参与评估的人员有部分是对ATAM评估不了解的，我首先介绍了一下ATAM架构评估的方法和目的，leader和leader+1等人介绍项目的意义和动机。最后作为系统架构师的我描述整个系统的的架构实现，针对架构的各个组成部分进行功能及讲解，各个模块的服务是如何协作，整个系统的数据流向是怎样的，并且针对系统存在的问题进行安全规划。
	在调查分析阶段，结合场景不同的角色需求方，都基于各自立场提出了相关的需求，需求及质量场景如下：
    (a)在正常网络负载情况下，平台在2S内响应用户操作请求。（性能）
    (b)平台能够抵御99.999%的黑客攻击。（安全性）
    (c)对查询请求处理时间的要求将影响系统的集群方式和数据处理过程设计。（敏感点）
    (d)网络失效后，平台要在3分钟内发现并启用备用网络系统。（可用性）
    (e)在平台升级时，要保证在1个月内添加一个新的消息处理中间件。（可修改性）
    (f)信息安全部提出的更改平台加密的级别对安全性和性能产生影响。（权衡点）
    (g)查询过程中，数据读取速度在30s完成。（性能）
    (h)主站点断电后，需要在3秒内将请求重定向到备用站点。（可用性）
    (i)更改用户使用界面接口必须在3天内完成。（可修改性）
    (j)对主播用户信息数据的授权访问必须保证99.999%的安全性。（安全性）
    (k)目前对“直播数据实时监控”业务逻辑的描述尚未达成共识，这可能导致部功能开发不明确，影响系统的可修改性。（风险点）
	经过分析总结我们获得了质量属性效用树，属于性能的有a和g，可用性的有d和h，属于安全性的有b和j，属于可修改性的有e和i等。在这些场景的分析中还评估分析了系统的架构风险点、敏感点和权衡点。风险点是指架构设计中潜在的、存在问题的架构决策所带来的隐患，其中k描述的是架构风险。敏感点是为实现某个特定的质量属性，一个或多个构件具有的特性，其中c属于敏感点；权衡点是影响多个质量属性的特性，是多个质量属性的敏感点，其中f属于权衡点。
	在测试阶段，结合直播的特殊性，经过项目干系人集体讨论，确定了不同场景的优先级：安全性、可用性最高，性能和可修改性其次，其他的属性最低。在平台安全性方面使用了SSL数字证书的https访问协议，网络设备使用了网闸、多层异构防火墙、入侵防护系统，数据访问使用分级授权和数据加密存储。可用性方面使用集团自建的云平台加心跳技术，当服务器出现问题时自动迁移到冗余主机。性能方面采用了中间件集群的方式，联机分析查询引擎使用Presto，它带来的查询效率远远大于Hive引擎和Spark引擎。可修改行方面平台对功能服务做了拆分，通过接口调用实现便捷修复。
	报告阶段，经过架构评估，将评估的过程和结果都汇总整理成文档。其中包括架构分析方法文档、不同场景及各自的优先级，质量效用树、风险点、敏感点、权衡点的决策，每次评估会议的记录。
	经过我和团队的不懈努力，历时一年多，项目于2020年7月上线，整个系统运行稳定，达到了预期的目标和要求，提高了集团的业务处理的效率，创造了极大的价值。但是，在实施过程中也存在一些问题，由于数据中台里面存在很多大数据任务，如果大数据任务不分优先级同时在跑，那计算资源很快就会变得特别紧张，导致核心任务不能及时跑完，因此需要建立具有动态优先级调整机制的处理队列，让核心任务优先使用计算资源。我们也已经把这些经验和教训以文档的方式记录下来，供其他技术人员学习，为今后系统架构设计提供帮助。
```

### 面向服务的架构（企业集成架构）

**摘要**

​	2019年4月，我参加国内某一线互联网大厂的直播数据中台项目的开发。该平台解决了集团下各个app等直播模块数据孤岛问题，通过数据中台统一服务的方式解决能力横向复用难、重复造轮子的问题，带来的收益是补齐了直播业务缺失的数据统计能力和减少了维护成本，以及只要是接入中台的产品，能快速应用一套统计体系。我作为该项目的架构师和主要负责人，主要完成了需求分析，架构分析和设计平台系统架构。通过团队一整年的努力，平台开发顺利完成并上线，整个系统已经稳定运行3年了，顺利达到了既定目标。本文作者结合实际的项目经验，以该项目为例，论述如何基于SOA理念设计项目的服务架构。主要讨论SOA技术框架的概念，包含的服务类型、主要技术和实现方式。

**正文**

```text
	2020年以前，集团下的各个app都有直播模块，各app的直播是各团队自己迭代维护的，业务团队独立、研发团队独立、数据团队逻辑上也是独立。这带来了以下问题：1.能力横向复用难，重复造轮子问题。例如，一个功能、一套方法论，在某app端验证效果好，想要移植到另一个app，需要重新开发，这也带来了重复造轮子的问题。2.因为重复造轮子，也就造成了产品、研发、运营人力和成本的浪费。3.同时会造成对外品牌认知不统一，品牌效应难以拓展延申的问题。正是在这一背景下，集团提出建设直播数据中台，该项目既补齐了直播业务缺失的数据统计能力，比如，口径统一，对齐了各产品的数据口径，减少了沟通成本，同时统一了维护，减少了维护成本，以及只要是接入中台的产品，能快速应用一套统计体系。
	在架构设计之初我分析了将要开发的所有模块的特点。由于系统的组成模块较多，各个模块的开发语言、架构风格、执行标准等都可能有所不同，为保证各个模块之间以统一通用的方式进行交互，满足系统整体标准化、松耦合和可移植性等多方面因素后，我决定采用面向服务的架构设计来开发该系统。本文首先阐述SOA主要的技术和标准及每种技术和标准的具体内容，并论述如何使用面向服务架构开发系统，最后描述本次项目开发过程中面向服务架构时遇到了哪些问题和解决方案以及个人感悟。
	SOA是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口联系起来。接口是采用中立的方式定义，独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。与 SOA 紧密相关的技术主要有UDDI、WSDL和SOAP。其中UDDI（统一描述、发现和集成）提供了一种服务发布、查找和定位的方法，是服务的注册规范，主要包含数据模型、API和注册服务三项内容；WSDL（服务描述语言）是对服务进行描述的语言，它有一套基于 XML 的语法定义，包含服务实现定义和服务接口定义；SOAP（简单对象访问协议）定义了服务请求者和服务提供者之间的消息传输规范。SOAP 用 XML 来格式化消息，用HTTP来承载消息。通过SOAP应用程序可以在网络中进行数据交换和远程过程调用。SOA主要的实现方式有WebService、ESB和服务注册表，本次在项目中使用的是WebService方式实现SOA。在该方式中包含三个重要角色，分别是服务提供者、服务请求者和服务注册中心，下面说明具体的构建过程及遇到的问题和实施效果。
	服务提供者，主要完成服务的设计、描述、定义和发布工作。通过对业务的分析梳理，并综合考虑粗粒度、松耦合、自包含等特点对服务进行了设计。同时为了避免服务间通信量过大、交互频繁，尽量减少了服务的数量。经设计初步提炼出设备接入、消息处理、规则反馈和业务分析四个主要服务。其中设备接入服务与网关设备相接的服务，负责与网关设备进行消息交互；消息处理服务在网关设备接入服务和业务分析服务之间将输入的消息经过顺序处理和转换后产生输出流；规则反馈服务为使用频率较高的消息自动执行反馈及相应操作；业务分析服务负责系统管理、设备管理、网络组件管理、通知管理、规则管理、日志管理等。
	服务请求者，服务的请求者即是服务的消费者，通过服务注册中心可查找、绑定和调用服务。系统中主要的流程是设备信息收集和业务结果反馈。数据中心管理系统利用服务注册中心获取对应的服务接口、参数和返回值实现动态绑定。在设备信息收集阶段，设备通过设备接入服务将消息发送到消息处理服务，消息经过格式转换后发送到规则反馈或业务分析。在业务结果反馈阶段，业务分析或规则反馈服务将处理结果通过消息处理后发送到设备。在服务调用期间请求者不需要关心服务提供者的业务处理和技术实现，只需关注自身业务，简化了开发流程提升了工作效率。
	服务注册中心，服务注册中心是连接服务提供者和服务请求者的纽带，服务提供者在此发布服务描述，服务请求者在此查找需要的服务。虽然在某些情况下服务注册中心是可选角色，但注册中心的存在可使服务提供者和服务消费者进一步解耦。本项目为了保证系统中各服务间松耦合和相互独立性，在架构设计中使用了该技术，注册中心内包含已发布的**设备接入、消息处理、规则反馈和业务分析**四项服务，其描述信息主要包括服务功能描述、参数描述、接口定义等相关内容。
	从本次项目开发整体来看，SOA架构的使用使模块间耦合度降低，提高了系统的性能，可用性和可修改性等多项指标，满足公司的预期要求，保证系统后期的快速二次开发和数据接入。但在系统开发过程中也遇到一些问题，由于SOAP是基于XML方式通信效率较低，当消息爆发式增长时，会造成大量的消息积压，无法得到及时解决，因为消息的反馈并没有严格的顺序要求，所以我选择增加路由灵活、容错能力好的消息中间件Kafka和升级硬件组合方案来解决该问题。
	经过我和团队的不懈努力，历时一年多，项目于2020年7月上线，整个系统运行稳定，达到了预期的目标和要求，提高了集团的业务处理的效率，创造了极大的价值。但是，在实施过程中也存在一些问题，由于数据中台里面存在很多大数据任务，如果大数据任务不分优先级同时在跑，那计算资源很快就会变得特别紧张，导致核心任务不能及时跑完，因此需要建立具有动态优先级调整机制的处理队列，让核心任务优先使用计算资源。我们也已经把这些经验和教训以文档的方式记录下来，供其他技术人员学习，为今后系统架构设计提供帮助。
```

### 云原生架构（微服务架构同样适用）

**摘要**

​		2019年4月，我参加国内某一线互联网大厂的直播数据中台项目的开发。该平台解决了集团下各个app等直播模块数据孤岛问题，通过数据中台统一服务的方式解决了能力横向复用难、重复造轮子的问题，带来的收益是补齐了直播业务缺失的数据统计能力和减少了维护成本，以及只要是接入中台的产品，能快速应用一套统计体系。我作为该项目的架构师和主要负责人，主要完成了需求分析，架构分析和设计平台系统架构。本文作者结合实际项目经验，以该项目为例，主要论述云原生架构在项目中的具体应用。本文将项目简单划分为前端 Web 服务、平台保障服务、平台业务服务三部分去介绍，着重讨论每一部分的具体应用和实现。通过团队一整年的努力，平台开发顺利完成并上线，整个系统已经稳定运行3年了，顺利达到了既定目标。

**正文**

```text
	2020年以前，集团下的各个app都有直播模块，各app的直播是各团队自己迭代维护的，业务团队独立、研发团队独立、数据团队逻辑上也是独立。这带来了以下问题：1.能力横向复用难，重复造轮子问题。例如，一个功能、一套方法论，在某app端验证效果好，想要移植到另一个app，需要重新开发，这也带来了重复造轮子的问题。2.因为重复造轮子，也就造成了产品、研发、运营人力和成本的浪费。3.同时会造成对外品牌认知不统一，品牌效应难以拓展延申的问题。正是在这一背景下，集团提出建设直播数据中台，该项目既补齐了直播业务缺失的数据统计能力，比如，口径统一，对齐了各产品的数据口径，减少了沟通成本，同时统一了维护，减少了维护成本，以及只要是接入中台的产品，能快速应用一套统计体系。
	在架构设计之初我分析了将要开发的所有模块的特点。由于系统的组成模块较多，各个模块的开发语言、架构风格、执行标准等都可能有所不同，为保证各个模块之间以统一通用的方式进行交互，满足系统整体标准化、松耦合和可移植性等多方面因素后，本项目将采用云原生架构作为具体的应用。云原生架构以微服务和容器技术为代表，有服务化、弹性、可观测性和自动化四类设计原则。通过服务化的设计原则，应用被分解为多个服务，可分别选择不同的技术，单个服务模块很容易开发、理解和维护，无需担心其他服务对本服务的影响；通过弹性的设计原则，微服务可以分布式云化部署，负载均衡管理请求的分发，避免单机失败对整体服务的影响，以及弹性调整资源容量；通过可观测性的设计原则，能够对系统进行健康检查、指标监控、日志管理和链路追踪，提高系统运维、管理和排错能力；通过自动化的设计原则，可实现系统的自动化部署、自动化扩展伸缩、自动化运维、持续交付和集成，有效减少人工操作的工作量。
	本项目以Spring Cloud 微服务框架开发，分为前端 Web 服务、平台保障服务、平台业务服务三部分。前端 Web 服务由负载均衡与服务器集群结合，实现高并发的前台界面；平台保障服务以 Eureka 为中心，由 API 网关、服务注册中心、监控平台等构成，实现基础服务框架；业务服务划分为多个微服务，基于 Docker 容器，协同工作实现具体业务功能。下面针对这三类服务展开具体说明。
	前端 Web 服务主要提供给用户使用的界面，分为前置 Nginx 负载均衡服务器、前端网站 Nginx 集群。当用户通过网络访问系统时，首先会访问到前置的Nginx 负载均衡服务器，负载均衡服务器会将请求转发到前端网站的 Nginx 集群，前端网站通过发起 http 请求来和后端交互，具体是通过 Ajax 方式来调用后端REST API 接口。用户访问网站通过前置的 Nginx 负载均衡服务器来转发到前端网站集群，以起到将用户请求进行分流的作用。当前端网站集群中的部分服务发生故障时，系统仍可正常地对外提供服务。前置 Nginx 负载均衡服务器使用软件反向代理的方式来实现负载均衡，部署为路由模式，系统内部网络与外部网络分属于不同的逻辑网络，以实现系统内部与外部网络的隔离。在负载均衡算法的选择上，使用最小连接法，每当用户的请求来临时，任务分发单元会将任务平滑分配给最小连接数的前端网站节点，这样的架构以廉价且透明的方式扩展了服务器和网络的带宽，可以大大提升系统的并发量，同时保证网站前端整体的稳定性和可靠性。
	平台保障服务用以实现后端微服务的基础框架，包括 API 路由网关、服务注册中心、服务监控组件。API 网关收到前端的请求，不会直接调用后端的业务服务，而是首先会从服务注册中心根据当前请求来获取对应的服务配置，随后通过服务配置再调用已注册的服务。当后端微服务存在多个实例时，将采取负载均衡的方式调用。服务注册中心是整个云原生架构体系的核心部分，由 Spring Cloud的 Eureka 组件来实现，专门提供微服务的服务注册和发现功能，涉及三种角色：服务提供者、服务消费者和服务注册中心。API 路由网关、所有业务服务，以及服务监控平台组件都注册到服务注册中心。通过服务注册中心两两互相注册、API 路由网关向服务注册中心注册多个实例等方式，来实现后端整体服务的高可靠性。服务监控平台通过注册到服务注册中心，获取所有注册到服务注册中心的后端业务服务，从而监控到所有后端业务服务的运行状态信息，最后收集并展示整个微服务系统的运行状态，更进一步保证整个后端的服务质量。
	平台业务服务按功能模块，相应划分为数据开发服务、数据查询和分析服务、数据管理服务、数据备份服务、数据容灾服务等。各服务单独打包，基于 Docker 容器，连同运行环境一起封装，根据实际情况可在一台或多台物理机同时部署多个实例，服务启动后会将自身信息注册到服务注册中心。服务间协同工作，通过松耦合的服务发现机制，动态调用对方 REST API 接口。对于压力较大的服务，如数据查询和分析服务，将部署为多实例集群。以用户界面在线编辑SQL功能为例，用户进入界面时，核验用户信息通过，调用数据管理服务，返回相应数据权限给用户。用户提交SQL查询时，提交的SQL任务到达MQ 队列排队。然后由负载均衡机制，依次将队列中任务进行执行，返回相应的数据给前端界面。在此期间服务请求者无需了解其他服务对数据如何具体处理和分析。
	在业务发展初期只有几个微服务，这时用 Docker 就足够了，但随着业务规模逐渐扩大，容器越来越多，运维人员的工作越来越复杂，这个时候就需要编排系统解救。目前业界比较流行的有KS8和Docker Swarm，Docker Swarm 是 Docker 自家针对集群化部署管理的解决方案，优点很明显，可以更紧密集成到 Docker 生态系统中。但是考虑商业和生态的原因，本项目最终选择了ks8。ks8和Docker共同构成了现代微服务架构和云原生架构的基石，Docker解决了应用程序的容器化问题，而ks8则负责容器的自动化管理和编排。这两者相辅相成，使得开发者可以更加轻松地构建、部署和管理微服务和云原生应用程序。
	经过我和团队的不懈努力，历时一年多，项目于2020年7月上线，整个系统运行稳定，达到了预期的目标和要求，提高了集团的业务处理的效率，创造了极大的价值。但是，在实施过程中也存在一些问题，由于数据中台里面存在很多大数据任务，如果大数据任务不分优先级同时在跑，那计算资源很快就会变得特别紧张，导致核心任务不能及时跑完，因此需要建立具有动态优先级调整机制的处理队列，让核心任务优先使用计算资源。我们也已经把这些经验和教训以文档的方式记录下来，供其他技术人员学习，为今后系统架构设计提供帮助。
```

### 安全性设计（还需要修改，加入相应的安全技术）

**摘要**

​	2019年4月，我参加国内某一线互联网大厂的直播数据中台项目的开发。该平台解决了集团下各个app等直播模块数据孤岛问题，通过数据中台统一服务的方式解决能力横向复用难、重复造轮子的问题，带来的收益是补齐了直播业务缺失的数据统计能力；减少了维护成本；接入中台的产品，能快速应用一套统计体系。我作为该项目的架构师和主要负责人，主要负责设计平台系统架构。本文作者结合实际经验，以该项目为例，从直播数据安全的角度来探讨信息系统的安全性和保密性，分别从数据分类与敏感性设计、数据加密、访问控制、数据备份和灾难恢复以及数据审计和监控五个方面进行介绍，最后总结项目中所遇到的问题。通过团队一整年的努力，平台顺利完成开发和上线，整个系统已经稳定运行2年了，顺利达到了既定目标。

**正文**

```text
	2019年以前，集团下的各个app都有直播模块，各app的直播是各团队自己迭代维护的，业务团队独立、研发团队独立、数据团队逻辑上也是独立。这带来了以下问题：1.能力横向复用难，重复造轮子问题。例如，一个功能、一套方法论，在某app端验证效果好，想要移植到另一个app，需要重新开发，这也带来了重复造轮子的问题。2.因为重复造轮子，也就造成了产品、研发、运营人力和成本的浪费。3.同时会造成对外品牌认知不统一，品牌效应难以拓展延申的问题。正是在这一背景下，集团提出建设直播数据中台，该项目既补齐了直播业务缺失的数据统计能力，比如，口径统一，对齐了各产品的数据口径，减少了沟通成本，同时统一了维护，减少了维护成本。只要是接入中台的产品，能快速应用一套统计体系。
	数据安全性设计是任何信息系统安全架构中至关重要的部分。在该项目中，我们应用了数据安全的理论原则，包括数据机密性、完整性和可用性（CIA三要素）。理论中强调了对数据的保护，以确保数据不会在传输和存储过程中泄露、被篡改或丢失。通过数据加密技术，我们实现了这些理论原则的实际应用。敏感数据被加密，而访问控制策略确保了数据的保密性。此实践不仅满足了理论要求，还有效地应对了项目的需求。接下来我会从数据分类与敏感性分析、数据加密、访问控制、数据备份与灾难恢复以及数据审计和监控五个方面进行详细阐述。
	在数据安全性设计中，首要任务是对数据进行分类和敏感性分析。这有助于确定哪些数据需要额外的保护。在直播数据中台项目中，我们将数据分为不同的类别，如主播信息、用户信息、直播时长、打赏记录、点赞次数、支付数据、操作日志等。然后，对每个数据类别进行敏感性分析，确定哪些数据属于敏感数据，需要更严格的保护。如主播信息包括了主播身份、联系信息和个人信息，这些信息在隐私保护方面至关重要，因此被视为敏感信息，需要额外的保护，以防止未经授权的访问。支付数据包括用户的支付历史、信用卡信息等，是极其敏感的数据。这些信息可能受到金融监管法规的约束，因此需要采用最高级别的数据安全措施，如加密和访问审计。通过对数据的分类和敏感性分析，我们能够明智地制定安全策略，确保敏感数据得到适当的保护，同时遵循数据隐私法规，降低数据泄露的风险。这一步骤是数据安全性设计中的关键组成部分，确保系统的数据保密性、完整性和可用性。
	数据加密是数据安全的核心措施之一。在项目中，我们采用了加密算法来保护数据的机密性。用户的个人信息、支付数据以及其他敏感数据都经过加密处理，以确保只有授权用户能够解密和访问这些数据。加密技术包括对数据传输的加密（使用TLS/SSL协议）和对数据存储的加密（使用数据库加密或文件级别加密）。数据加密不仅保护数据的机密性，还有助于遵守数据保护法规，如GDPR和HIPAA等，这些法规要求数据的安全性和隐私性得到充分保护。通过数据加密，我们不仅满足了法规要求，还建立了用户和利益相关者对数据安全性的信任。需要强调的是，选择适当的加密算法和密钥管理方法非常重要。在项目中，我们采用了强密码学算法，并实施了严格的密钥管理策略，以确保加密的数据不容易受到破解或未经授权的访问。这种综合的数据加密方法是确保数据安全性的有效手段，使数据在传输和存储过程中得到全面保护。
	访问控制是确保数据只被授权用户访问的重要手段。我们实施了严格的访问控制策略，包括基于角色的访问控制和基于权限的授权。只有通过身份验证的用户，并且拥有相应的权限，才能访问特定数据。这种措施确保了数据的保密性和完整性。基于角色的访问，我们将用户分为不同的角色，如管理员，数据分析师、普通开发人员等。管理员一般由leader和leader+1来担任，拥有最高级别的权限，可以访问和管理所有数据，而普通用户的权限则受到限制，只能访问与其工作职责相关的数据。这种基于角色的控制策略有助于简化权限管理，降低了管理工作量，并确保了数据的合法访问。
	数据安全不仅涉及数据的保护，还需要考虑数据的可用性。我们实施了定期的数据备份策略，以确保数据在发生灾难性事件时可以进行恢复。这包括定期的数据库备份和存储在多个服务器位置的备份数据。同时，我们进行了灾难恢复计划，以确保在不可抗力事件发生时，系统可以迅速恢复正常运行。灾难恢复主要包括以下关键方面：备份恢复，确保备份数据的有效性和可用性，以便在需要时能够快速还原数据；替代数据中心，我们选择了备用数据中心，以确保在主要数据中心不可用时，系统可以迅速切换到备用数据中心，保持业务的连续性；指定了灾难恢复团队，他们负责执行灾难恢复计划，确保系统在最短的时间内恢复正常运行。
	为了保障数据的安全性，我们引入了数据审计和监控机制。数据审计记录了数据的访问和操作历史，以便追踪和调查潜在的安全事件。数据监控工具用于实时监测数据的访问和传输，以及检测异常行为。例如，如果某个用户尝试多次无效的登录尝试，监控工具可以识别此类行为并触发警报。同样，如果数据传输出现异常模式，如大规模数据下载或未经授权的数据传输，监控工具也能立即检测到并采取相应的行动。这种实时监控有助于及早发现潜在的安全威胁和数据泄露风险。这些措施有助于快速识别潜在的安全威胁和数据泄露。
	经过我和团队的不懈努力，历时一年多，项目于2020年7月上线，整个系统运行稳定，达到了预期的目标和要求，提高了集团的业务处理的效率，创造了极大的价值。但是，在实施过程中也存在一些问题，由于数据中台里面存在很多大数据任务，如果大数据任务不分优先级同时在跑，那计算资源很快就会变得特别紧张，导致核心任务不能及时跑完，因此需要建立具有动态优先级调整机制的处理队列，让核心任务优先使用计算资源。我们也已经把这些经验和教训以文档的方式记录下来，供其他技术人员学习，为今后系统架构设计提供帮助。
```

### 可靠性设计

### 大数据架构、数据湖、湖仓一体架构设计

**摘要**

​	2019年4月，我参加国内某一线互联网大厂的直播数据中台项目的开发。该平台解决了集团下各个app等直播模块数据孤岛问题，通过数据中台统一服务的方式解决能力横向复用难、重复造轮子的问题，带来的收益是1.补齐了直播业务缺失的数据统计能力；2.统一维护，减少了维护成本；3.只要是接入中台的产品，能快速应用一套统计体系。我作为该项目的架构师和主要负责人，主要完成了需求分析、系统架构分析和设计等工作。通过团队一整年的努力，平台开发完成并顺利上线，整个系统已经稳定运行3年了，顺利达到了既定目标。本文作者结合实际经验，以该项目为例，讨论大数据架构的设计，包括Lambda架构、Kappa架构以及Lambda-Kappa架构的结合。

**正文**

```
	2020年以前，集团下的各个app都有直播模块，各app的直播是各团队自己迭代维护的，业务团队独立、研发团队独立、数据团队逻辑上也是独立。这带来了以下问题：1.能力横向复用难，重复造轮子问题。例如，一个功能、一套方法论，在某app端验证效果好，想要移植到另一个app，需要重新开发，这也带来了重复造轮子的问题。2.因为重复造轮子，也就造成了产品、研发、运营人力和成本的浪费。3.同时会造成对外品牌认知不统一，品牌效应难以拓展延申的问题。正是在这一背景下，集团提出建设直播数据中台，该项目既补齐了直播业务缺失的数据统计能力，比如，口径统一，对齐了各产品的数据口径，减少了沟通成本，同时统一了维护，减少了维护成本，以及只要是接入中台的产品，能快速应用一套统计体系。
	常见的大数据架构有Lambda架构、Kappa架构，以及后来Kappa-Lambda架构，现在分别对三种架构进行阐述，并以Kappa-Lambda架构作为实际案例进行深入讲解。Lambda架构由三层组成：批处理层、速度处理层、服务层。批处理层存储管理主数据集和预先批处理计算好的视图。速度处理层会实时处理新来的大数据。本质上速度层弥补了批处理层所导致的数据视图滞后，比如说，批处理层的每个任务都需要 1 个小时才能完成，而在这 1 个小时里，我们是无法获取批处理层中最新任务给出的数据视图的。而速度层因为能够实时处理数据给出结果，就弥补了这 1 个小时的滞后。服务层，所有批处理层和速度层处理完的结果都会输出存储到服务层中，服务层通过返回预先计算的数据视图或速度层处理构建好数据视图来响应查询。
	Kappa架构包含两层：流式处理层、服务层。流式处理层：通过流式处理系统接收所有数据，并进行实时计算，更新存储中的结果视图。服务层：对外提供查询服务，直接基于流式处理层更新的结果视图进行查询返回。对比Lambda架构需要维护两套引擎，Kappa架构只需要维护一套引擎，复杂度低、开发、维护成本低。它能够很好地满足实时性，但是历史数据处理能力相对较弱。Lambda架构批式全量处理，吞吐量大，历史数据处理能力强；而Kappa架构流式全量处理，吞吐量相对较低，历史数据处理能力相对较弱。
	Kappa-Lambda架构是在Kappa架构的基础上，引入了Lambda架构中的批处理层组件，形成的一种混合架构。Kappa-Lambda架构相比Kappa架构，引入了批处理层组件，以便进行复杂的历史数据分析。同时保留了Speed层，进行低延迟的实时计算。架构组件有Stream层，负责实时流式处理层；Serving层，负责查询服务层；Batch层，批处理层，用于复杂的历史数据分析；Speed层，速度层，用于低延迟的实时计算。工作流程：Stream层接收实时数据，进行实时计算；Speed层从Stream层获取实时结果，进行低延迟的实时分析；Serving层查询时，实时部分从Speed层获取，历史部分从Batch层获取；Batch定期从Stream层获取数据，进行复杂的历史数据分析和处理。
	直播数据中台是采用Kappa-Lambda架构来构建的，在Kappa架构实现中，采用HDFS作为数据的存储，yarn作为资源的调度，离线计算方面采用spark，实时计算方面采用Flink，HBase作为服务层，Hive创建可查询的视图。Hadoop由HDFS、Yarn、Mapreduce三部分组成。HDFS是分布式文件系统，具有高度容错性、能够提供高吞吐量的数据访问，非常适合大规模数据集上的应用。Yarn是资源调度器，负责处理客户端的请求，进行资源的调度和分配。有FIFO调度器，支持单队列，先进先出；容量调度器，支持多队列，保证先进入的任务优先执行；公平调度器，支持多队列，保证每个任务享有队列资源。本项目中采用的是容量调度器，容量调度器中多队列的好处是避免了某个程序出现死循环，把资源耗尽；可以实现任务的降级，特殊时期保证重要任务的队列资源充足。Mapreduce分为Map和Reduce两个阶段，主要负责离线批处理计算。
	Spark是基于内存的分布式计算架构，数据分析更加快速，适合低时延环境下计算的应用。相比Mapreduce过程中会重复的读写hdfs，造成大量的磁盘io读写操作，Spark中间输出结果可以保存在内存中，从而不需要读写HDFS，极大提高了计算的效率和速度。RDD是spark的最基本数据抽象，它是弹性分布式数据集，代表的是一个不可变、可分区、可并行计算机的集合。它的作用是：提供了一组抽象的数据模型，将具体的应用逻辑表达成一系列的转换操作。不同的RDD之间的转换操作会形成依赖关系，进而实现管道化，大大降低数据的复制、磁盘I/O。RDD的依赖分为宽依赖和窄依赖，在划分任务时起到重要作用。
	Flink是一个分布式处理引擎框架，用于对无界和有界数据流进行状态计算。flink可以完全独立于Hadoop，在不依赖于hadoop组件下运行。但是作为大数据的基础设施，hadoop体系是任何大数据框架都绕不过去的。flink可以集成众多hadoop组件，例如yarn、hbase、hdfs等等。flink可以和yarn集成做资源调度，也可以读写hdfs，或者利用hdfs做检查点。HBase是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价的机器上搭建起大规模结构化存储集群。
	在整个大数据架构中，需要消息队列作为中间件，起到缓冲的作用。如何保证消息队列数据的不丢失是整个设计的关键。消息队列采用的是Kafka，组成：生产者、Broker(Kafka服务器)、消费者、Zookeeper。Zookeeper只保存了Broker的id信息，以及消费者的offset信息；没有生产者的信息。解耦和扩展性：将生产者和消费者解耦开来，可以独立地扩展他们相应的功能。缓冲和削峰：如果上游数据突然暴增，下游可能扛不住。所有可以通过消息队列进行缓冲，下游队列可以慢慢从消息队列取数据处理。
异步处理：有时候并不需要立即处理数据，可以通过消息队列的异步处理机制，它允许用户把消息放入消息队列里，但不立即处理它。如何避免数据丢失？1. 生产者数据的不丢失
ACK机制：当Kafka发送消息的时候，都会有一个消息确认反馈机制，确保消息是否正常收到，有0，1，-1三种状态。ack=0，异步发送，消息发送完，立即发送下一条消息；ack=1，Producer等待Leader确认收到数据，才发送下一条消息；ack=-1，Producer等到Follower确认，才发送下一条消息2. 消费者数据的不丢失，通过Offset来保证每次消费的记录3. Broker数据不丢失，通过备份副本，来保证数据不丢失。
	经过我和团队的不懈努力，历时一年多，项目于2020年7月上线，整个系统运行稳定，达到了预期的目标和要求，提高了集团的业务处理的效率，创造了极大的价值。但是，在实施过程中也存在一些问题，由于数据中台里面存在很多大数据任务，如果大数据任务不分优先级同时在跑，那计算资源很快就会变得特别紧张，导致核心任务不能及时跑完，因此需要建立具有动态优先级调整机制的处理队列，让核心任务优先使用计算资源。我们也已经把这些经验和教训以文档的方式记录下来，供其他技术人员学习，为今后系统架构设计提供帮助。
```



​	

​	

​	



