# .Net

.net standard是标准，只是定义，没有实现

.net code和.net Framwork根据定义都有自己的实现



# await 和 async 异步编程

## 基本使用

”异步方法“用async关键字修饰的方法

1. 异步方法的返回值一般是Task<T>，T是真正的返回值类型，Task<int>。惯例：异步方法名字以Async结尾。
2. 即使方法没有返回值，也最好把返回值声明为非泛型的Task。
3. 调用泛型方法时，一般在方法前加await，这样拿到的返回值就是泛型指定的T类型；
4. 异步方法的“传染性”：一个方法中如果有await调用，则这个方法也必须修饰为async

```c#
namespace awaitasync
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            //同步方法
            /*
            string filename = @"E:\a\1.txt";
            File.WriteAllText(filename, "hello");
            string s = File.ReadAllText(filename);
            Console.WriteLine(s);
            */

            //异步方法
            string filename = @"E:\a\2.txt";
            await File.WriteAllTextAsync(filename, "word");
            //加了await，Task自动会把string取出来
            string s = await File.ReadAllTextAsync(filename);
            //不加await，返回的是Task类型
            //Task<string> t = File.ReadAllTextAsync(filename);
            //string s1 = await t; // 要想取出string，还得用await，所以一般用aync方法都会加await
            //string s2 = t.Result;//假如main不能使用aysnc方法，有返回值的话使用Result来获取，没有返回值的话使用Wait(),Wait()表示等待异步方法结束
            Console.WriteLine(s);
            //Console.WriteLine(s1);
        }
    }
}
```

如果同样的功能，既有同步方法，又有异步方法，首先使用异步方法。

对于不支持的异步方法怎么办？无返回值使用Wait()，有返回值使用Result。风险：死锁，尽量不用。

```c#
namespace awaitasync
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
           
            await DownloadHtmlAsync("http://www.baidu.com", @"E:\a\baidu.txt");
            Console.WriteLine("ok");

            int count = await DownloadHtmlLengthAsync("http://www.baidu.com", @"E:\a\baidu1.txt");
            Console.WriteLine($"{count}");
        }

        //不带返回值的方法
        static async Task DownloadHtmlAsync(string url, string filename)
        {
            //推荐用HttpClientFactory
            //由于HttpClient有继承IDisposable接口，意味着这个类需要手动释放的非托管资源（文件句柄、网络连接、数据连接等）
            //推荐使用using语句来确保资源被正确释放
            using (HttpClient httpClient = new HttpClient())
            {
                string html = await httpClient.GetStringAsync(url);
                await File.WriteAllTextAsync(filename,html);
            }
        }

        //带返回值的方法
        static async Task<int> DownloadHtmlLengthAsync(string url, string filename)
        {
            //推荐用HttpClientFactory
            //由于HttpClient有继承IDisposable接口，意味着这个类需要手动释放的非托管资源（文件句柄、网络连接、数据连接等）
            //推荐使用using语句来确保资源被正确释放
            using (HttpClient httpClient = new HttpClient())
            {
                string html = await httpClient.GetStringAsync(url);
                await File.WriteAllTextAsync(filename, html);
                return html.Length;
            }
        }
    }
}
```

异步委托

```c#
ThreadPool.QueueUserWorkItem(async (obj) => {
    await SomeAync();
})
```

## 基本原理

async的方法会被c#编译器编译成一个类，会主要根据await调用进行切分为多个状态，对async方法的调用会被拆分为对MoveNext的调用。用await看似是“等待”，经过编译后，其实没有wait。

## 多线程

await调用的等待期间，.net会把当前的线程返回给线程池，等异步方法调用执行完毕后，框架会从线程池再取出一个线程执行后续的代码。

也就是说await之前和之后的线程可能不是同一个线程。

细节：如果执行操作耗时比较少，会发现线程Id不变。

优化：到要等待的时候，如果发现已经执行结束了，那就没必要再切换线程了，剩下的代码继续在之前的线程上继续执行了。

```text
aaa;//线程1执行
awati AAsync();
bbb;//有可能是线程1，也有可能是线程2执行
```

异步方法的代码并不会自动在新线程中执行，除非把代码手动放到新线程中执行。

```c#
namespace 线程切换
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("之前的线程：" + Thread.CurrentThread.ManagedThreadId);
            double r = await CalcAsync(500);
            Console.WriteLine($"r={r}");
            Console.WriteLine("之后的线程：" + Thread.CurrentThread.ManagedThreadId);

        }

        public static async Task<double> CalcAsync(int n)
        {
            Console.WriteLine("CalcAsync：" + Thread.CurrentThread.ManagedThreadId);
            //模拟一个耗时的操作
            double result = 0;
            Random rand = new Random();
            for(var i=0; i < n * n; i++)
            {
                result += rand.NextDouble();
            }
            return result;
        }
    }
}

之前的线程：1
CalcAsync：1
r=124940.60847503919
之后的线程：1
```

手动放在新的线程里

```c#
namespace 线程切换
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("之前的线程：" + Thread.CurrentThread.ManagedThreadId);
            double r = await CalcAsync(500);
            Console.WriteLine($"r={r}");
            Console.WriteLine("之后的线程：" + Thread.CurrentThread.ManagedThreadId);

        }

        public static async Task<double> CalcAsync(int n)
        {
            
            //手动放在一个新的线程里
            return await Task.Run(() =>
            {
                Console.WriteLine("CalcAsync：" + Thread.CurrentThread.ManagedThreadId);
                //模拟一个耗时的操作
                double result = 0;
                Random rand = new Random();
                for (var i = 0; i < n * n; i++)
                {
                    result += rand.NextDouble();
                }
                return result;
            });
        }
    }
}

之前的线程：1
CalcAsync：5
r=125097.21736538746
之后的线程：5
```

如果一个异步方法只是对别的异步方法调用转发，并没有太多复杂的逻辑，那么可以去掉async关键字

```c#
namespace 线程切换
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("之前的线程：" + Thread.CurrentThread.ManagedThreadId);
            // double r = await CalcAsync(1000);
            double r = await Calc2Async(500);
            Console.WriteLine($"r={r}");
            Console.WriteLine("之后的线程：" + Thread.CurrentThread.ManagedThreadId);
        }

        //去掉async
        public static Task<double> Calc2Async(int n)
        {
            return Task.Run(() =>
            {
                Console.WriteLine("CalcAsync：" + Thread.CurrentThread.ManagedThreadId);
                //模拟一个耗时的操作
                double result = 0;
                Random rand = new Random();
                for (var i = 0; i < n * n; i++)
                {
                    result += rand.NextDouble();
                }
                return result;//Task.FromResult(result);
            });
        }
    }
}

之前的线程：1
CalcAsync：5
r=125083.75832039521
之后的线程：5
```

如果想在异步方法中暂停一段时间，不要用Thread.Sleep()，因为它会阻塞调用线程，而要用await Task.Delay()。比如：下载一个网址，3秒后下载另一个。

有时需要提前终止任务，比如：请求超时、用户取消请求。很多异步方法都有CancellationToken参数，用于获得提前终止执行的信号。



# LINQ

## 委托

委托是可以指向方法的类型，调用委托变量时执行的就是变量指向的方法。

`delegate` 是 C# 中用于**声明一个委托类型**的关键字。它是一种特殊的类型，它定义了一个方法的**签名**（即参数列表和返回类型）。可以把它看作是一个指向方法的**类型安全**的**函数指针**。

.net 中定义了泛型委托Action(无返回值)和Func(有返回值)，所以一般不用自定义委托类型。

```c#
namespace 委托
{
    internal class Program
    {
        static void Main(string[] args)
        {
            D1 d1 = F1;
            d1();
            d1 = F2;
            d1();
            D2 d2 = Add;
            Console.WriteLine(d2(3, 5));
            Action a = F1;
            a();
            Func<int,int,int> f = Add;
            Console.WriteLine(f(5,8));
        }

        static void F1 ()
        {
            Console.WriteLine("我是F1");
        }

        static void F2()
        {
            Console.WriteLine("我是F2");
        }

        static int Add(int x,int y)
        {
            return x + y;
        }
    }

    delegate void D1 ();
    delegate int D2 (int x,int y);
}
```

## Lambda表达式

委托变量不仅可以指向普通方法，还可以指向匿名方法。

匿名方法可以写成lambda表达式，可以省略参数数据类型，因为编译能根据委托类型推断出参数的类型，用=>引出来方法体。

```c#
namespace Lambda表达式
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Action f1 = delegate ()
            {
                Console.WriteLine("我是f1");
            };
            f1();
            //如果委托没有返回值，且方法体只有一行代码，可省略{}
            Action f11 = () => Console.WriteLine("我是f11");
            f11();
            Action<string, int> f2 = delegate (string n, int i)
            {
                Console.WriteLine($"n={n},i={i}");
            };
            f2("chenli",18);
            Func<int, int, int> f3 = delegate (int i, int j)
            {
                return i + j;
            };
            Console.WriteLine(f3(3, 5));
            //Lambda表达式
            Func<int, int, int> f4 = (int i, int j) =>
            {
                return i + j;
            };
            Console.WriteLine(f4(3, 5));
            Func<int, int, int> f5 = (i, j) =>
            {
                return i + j;
            };
            Console.WriteLine(f5(3, 5));
            //如果=>之后的方法体中只有一行代码，且方法有返回值，那么可以省略方法体的{}以及return。
            Func<int, int, int> f6 = (i, j) => i + j;
            Console.WriteLine(f6(3, 5));
            //如果只有一个参数，参数的()可以省略。
            Func<int, bool> f7 = i => i > 5;
            Console.WriteLine(f7(7));
        }
    }
}
```

## LINQ

手写LINQ原理

```c#
namespace LINQ
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int[] nums = new int[] { 1, 2, 3, 4, 5, 6, 7 };
            //Where会遍历集合中每个元素，对于每个元素都调用a=>a>=5这个表达式，判断一下是否为true
            //如果为true，则把这个放到返回的集合中
            IEnumerable<int> result = nums.Where(a => a >= 5);
            foreach (int x in result)
            {
                Console.WriteLine(x);
            }
            //调用自己的版本1方法
            IEnumerable<int> result1 = MyWhere1(nums,a=>a>=5);
            foreach (int x in result1)
            {
                Console.WriteLine(x);
            }
            //调用自己的版本2方法
            IEnumerable<int> result2 = MyWhere2(nums, a => a >= 5);
            foreach (int x in result2)
            {
                Console.WriteLine(x);
            }
        }

        static IEnumerable<int> MyWhere1(IEnumerable<int> items, Func<int, bool>f) { 
            List<int> result = new List<int>();
            foreach (var item in items)
            {
                if (f(item) == true)
                {
                    result.Add(item);
                }
            }
            //一次性返回所有结果
            return result;
        }

        static IEnumerable<int> MyWhere2(IEnumerable<int> items, Func<int, bool> f)
        {
            
            foreach (var item in items)
            {
                if (f(item) == true)
                {
                    Console.WriteLine("MyWhere2:" + item);
                    //yield return 用于创建迭代器，它让方法能够按需生成序列中的元素，而不是一次性返回所有结果。
                    yield return item;
                }
            }
            
        }
    }
}
```

LINQ的扩展方法

```c#
using LINQ常用扩展方法;
using System.Collections.Generic;
using System.Reflection;
using System.Xml.Linq;

namespace LINQ常用扩展方法
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //初始化数据
            List<Employee> list = new List<Employee>();
            list.Add(new Employee { Id = 1, Name = "jerry", Age = 28, Gender = true, Salary = 5000 });
            list.Add(new Employee { Id = 2, Name = "jim", Age = 33, Gender = true, Salary = 3000 });
            list.Add(new Employee { Id = 3, Name = "lily", Age = 35, Gender = false, Salary = 9000 }); 
            list.Add(new Employee { Id = 4, Name = "lucy", Age = 16, Gender = false, Salary = 2000 }); 
            list.Add(new Employee { Id = 5, Name = "kimi", Age = 25, Gender = true, Salary = 1000 });
            list.Add(new Employee { Id = 6, Name = "nancy",Age = 35, Gender = false, Salary = 8000 });
            list.Add(new Employee { Id = 7,Name = "zack",Age = 35, Gender = true, Salary = 8500 });
            list.Add(new Employee { Id = 8, Name = "jack", Age = 33, Gender = true, Salary = 8000 });

            //Where()方法,过滤
            IEnumerable<Employee> result1 =  list.Where(e => e.Age > 30);
            foreach (Employee e in result1)
            {
                Console.WriteLine(e);
            }

            //Count()，获取条数
            Console.WriteLine(list.Count(e => e.Age > 20 && e.Salary >= 8000));

            //Any()，是否至少有一条数据,返回的是布尔类型
            Console.WriteLine(list.Any(e => e.Age < 18));

            //获取一条数据（是否带参数的两种写法）:
            /*
             * Single:有且只有一条满足要求的数据；没有数据或有多条数据满足他就会报错
             * SingleOrDefault:最多只有一条满足要求的数据；没有的话就返回默认值，有多条就报错
             * First:至少有一条，返回第一条；一个都没有就报错
             * FirstOrDefault:返回第一条或默认值。
             */
            Employee e1 = list.Single(e => e.Name == "jerry");
            Console.WriteLine(e1);
            Employee e2 = list.SingleOrDefault(e => e.Name == "chenli");
            Console.WriteLine(e2==null);
            Employee e3 = list.First(e => e.Age > 30);
            Console.WriteLine(e3);
            Employee e4 = list.FirstOrDefault(e => e.Age > 40);
            Console.WriteLine(e4==null);

            //排序
            /*
             * Order()对数据正序排序
             * OrderByDescending()倒序排序
             * 多规则排序：ThenBy()、ThenByDescending()
             */
            var result2 = list.OrderBy(e => e.Age);
            foreach (Employee e in result2)
            {
                Console.WriteLine(e);
            }
            var result3 = list.OrderByDescending(e => e.Salary);
            foreach (Employee e in result3)
            {
                Console.WriteLine(e);
            }
            var result4 = list.OrderBy(e => e.Age).ThenByDescending(e=>e.Salary);//年龄一样的再按工资来排序
            foreach (var e in result4)
            {
                Console.WriteLine(e);
            }
            //限制结果集，获取部分数据
            //Skip(n)跳过n条数据，Take(n)获取n条数据
            var result5 = list.Skip(3).Take(2);
            foreach (var e in result5)
            {
                Console.WriteLine(e);
            }
            //聚合函数：Max()、Min()、Average()、Sum()、Count()
            int a = list.Max(e => e.Age);
            Console.WriteLine(a);
            //分组：GroupBy(),可以使用var来简化编程，但是你要知道原始是什么样子的
            IEnumerable<IGrouping<int,Employee>> result6 = list.GroupBy(e => e.Age);
            foreach(IGrouping<int, Employee> g in result6)
            {
                Console.WriteLine(g.Key);
                Console.WriteLine("最大工资：" + g.Max(e=>e.Salary));
                foreach (Employee e in g)
                {
                    Console.WriteLine(e);
                }
                Console.WriteLine("*******");
            }
            //投影：把集合中的每一项转换为另外一种类型
            IEnumerable<int> ages = list.Select(e => e.Age);
            foreach (int age in ages)
            {
                Console.WriteLine($"{age}");
            }
            //集合转换：ToArray()、ToList()可以把IEnumerable<T>转换为数据类型和List类型
        }
    }
}
```

# 依赖注入

依赖注入(DI)是控制反转(IOC)思想的实现方式。

依赖注入简化模块的组装过程，降低模块之间的耦合度。

代码控制反转的目的：怎样创建xx对象 -> 我要xx对象

依赖注入是有“传染性”的，如果一个类的对象是通过DI创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值；但是如果一个对象是成员手动创建的，那么这个对象就和DI没有关系，他的构造函数中声明的服务类型参数就不会被自动赋值。

.net的DI默认是构造函数注入



# C#新语法

## 顶级语句

直接在C#文件中编写入口方法，不用类，不用Main。

同一个项目中只能有一个文件具有顶级语句。

顶级语句中可以直接使用await语法，也可以声明函数。

## 全局using指令

将global修饰符添加到using，这个命名空间就应用到整个项目，不用重复using。

通常创建一个专门用来编写全局using代码的c#文件。

如果csproj中启用了<ImplicitUsing>enable</ImplicitUsings>，编译器会自动隐式增加对于System、System.Lingq等常用命名空间的引入，不同各类型项目引入的命名空间也不一样。

## using资源管理的问题

实现了IDisposible接口的对象可以用using进行管理。

如果一段代码中有很多非托管资源需要被释放的话，代码中就会存在着多个嵌套的using语句。

在实现了IDisposable/IAsyncDisposable接口的类型的变量声明前加上using，当代码执行离开变量的作用域时，对象就会被释放。

## 可空的引用类型

c#数据类型分为值类型和引用类型两种，值类型的变量不可以为空，而引用类型变量可以为空。

如果不注意检查引用类型变量是否可空，就有可能造成程序中出现NullReferenceException异常。

```c#
int a = null;//值类型是不可以为null的
int? a = null;//可以
String s = null;//引用类型是可以为null的
```

csproj中<Nullable>enable</Nullable>启用可空引用类型检查

在引用类型后添加"?"修饰符来声明这个类型是可空的。对于没有添加"?"修饰符的引用类型的变量，如果编译器发现存在为这个变量赋值Null的可能性的时候，编译器会给出警告信息。

## record类型

c#中的==运算符默认是判断两个变量指向的是否是同一个对象，即使两个对象内容完全一样，也不相等。可以通过重写Equals方法、重写==运算符等来解决这个问题，不过需要开发人员编写非常多的额外代码。

在c#9.0增加了记录(record)类型的语法，编译器会为我们自动生成Equals、GetHashcode等方法。

```c#
public record Person(string FirstName, string LastName);

Person p1 = new Person("Yang", "Zack");
Person p2 = new Person("Yang","Zack");
Person p3 = new Person("Gates", "Bil!");
Console.Writeline(p1);
Console.WriteLine(p1==p2);//True
Console.WriteLine(p1==p3);//False
Console.WriteLine(p1.FirstName);
```

