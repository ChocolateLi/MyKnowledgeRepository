# Redis、MySQL技术原理总结

## Redis

### 1、Redis基本概况

**Redis是什么？（说说你对redis的理解）**

Redis是基于C语言编写的、高性能的非关系型键值对的数据库。

它的数据存在内存中，所以读写速度非常快，被广泛应用于缓存方向。

它的数据还可以写在磁盘中，保证了数据的不丢失。



**Redis的优缺点**

优点：

1. 基于内存，速度非常快
2. Redis是单线程的，避免了线程的切换开销以及多线程的竞争问题
3. 支持持久化。支持RDB和AOF两种持久化机制
5. 支持主从复制。主节点会自动将数据同步到从节点，可以进行读写分离

缺点：

对结构化查询比较差，并且受制于物理内存的限制，不适合海量数据的高性能读写



**Redis有哪些数据类型**

键的类型只能为字符串

值支持五种数据类型

string：字符串

list：列表

set：无序集合

hash：散列表

zset(SortedSet)：有序集合。带分数的set



**List和SortedSet有什么异同**

相同点：都是有序的，都可以获得某个范围的元素

不同点：

1. List是基于链表实现的，获取两端元素速度快，访问中间元素速度慢；有序集合是基于散列表和跳跃表实现的，访问元素的时间是O(logN)
2. 列表不能简单地更改元素的位置，而有序表可以，通过更改分数



**什么是跳跃表**

它是有序集合的实现，是基于多指针有序链表实现的，可以看成多个有序链表

![跳跃表](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png)

它有以下性质：

1. 它有多层结构，每一层都是一个有序链表，每一层至少包含两个链表节点，最底层的链表包含所有元素
2. 如果一个元素出现在某一层的链表中，那么在该层之下的链表都会包含该元素。即它们是包含关系
3. 链表中的每个节点都包含两个指针，一个指向同一层的下一个节点，另一个指向下一层的同一个链表节点

它的基本原理就是从算法从最稀疏的层次进行搜索，直至要查找的元素在该层的两个相邻元素之间，然后算法跳入下一层，重复刚才的搜索，直到找到需要查找的元素为止。

优点：插入非常快速，不需要进行旋转等操作来维护平衡性，也更容易实现





**Redis应用场景**

1. 缓存热点数据，缓解数据库的压力
2. 利用Redis原子性的自增操作来实现计数功能。比如统计用户点赞数、访问数等
3. 可以做简单的消息队列。可以使用Redis自身的发布/订阅模式，或者使用List来实现简单的消息队列，实现异步操作



### 2、缓存穿透、缓存雪崩、缓存击穿

**缓存穿透**

缓存穿透是指查询一个一定不存在的数据，比如id=-1，由于缓存命不中，就会去查询数据库，查询不到数据则不会写入缓存，这就导致了这个不存在的数据每次请求都要到数据库查询，一旦并发点高，就会造成缓存穿透。

![缓存穿透](D:\github\MyKnowledgeRepository\img\picture\缓存穿透.png)



**解决方案：**

1. 将空对象也缓存起来，并给它设置很短的时间，最长不超过5分钟
2. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被布隆过滤器拦截掉，从而避免对底层存储系统的查询压力。



**缓存雪崩**

如果缓存集中在一段时间内失效，发生大量缓存穿透，所有查询都落到数据库上，就会造成缓存雪崩。

![缓存雪崩](D:\github\MyKnowledgeRepository\img\picture\缓存雪崩.png)

**解决方案：**

把每个key失效的时间加上一个随机值，尽量让失效的时间点分布在不同时间点上。



**缓存击穿**

是指一个key非常热点，在不停地扛着大并发，当这个key失效时，持续的大并发量穿透缓存，直接请求数据库。就像一个屏障凿开了一个洞



**解决方案：**

设置Key永不过时



### 3、布隆过滤器 Bloom Filter

**概念**

布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。

布隆过滤器可以用于检索一个元素是否在集合中



优点：算法效率高

缺点：有一定的误识别率和删除困难



**原理**

当一个元素加入集合时，通过K个散列函数将这个元素映射成数组的K个点，把它们置为1。检索时，看这些点是不是都是1，就大概知道这个元素在不在集合里。如果这些点有任何一个0，则被检索的元素一定不在集合里。如果都是1，则可能在集合里。



Bloom Filter跟单哈希函数Bit-Map的区别在于：它使用了K个哈希函数，每个元素跟K个bit对应，从而降低冲突的概率

![Bloom Filter](D:\github\MyKnowledgeRepository\img\picture\布隆过滤器.png)

### 4、哨兵模式

在一个主从复制的集群中，如果主机挂掉了，哨兵会从机中挑选一台作为主机，并且设置它为从机的主机。如果之前的主机再次启动，也会成为从机。



### 5、Redis的持久化

持久化就是把内存的数据写到磁盘中，防止服务宕机导致内存数据丢失。

**RDB持久化**：对Redis的数据执行周期性地持久化，可以将某个时间点的所有数据都存放在磁盘上。可以将快照复制到其他服务器从而创建具有相同数据的服务器副本

**AOF持久化**：将每条写入命令作为日志写入到日志文件中，这个模式是只追加模式。



**如何选择？**

通常来说，应该使用两种持久化方案，以保证数据安全。



### 6、Redis单线程，为什么那么快？

1. 完全基于内存，速度非常快
2. 采用单线程，就避免了不必要的上下文切换和竞争条件，也就不会有多线程的切换导致消耗CPU，就不存在加锁释放锁的操作，也不会因为死锁而导致性能消耗。
3. 使用了多路I/O复用模型，非阻塞I/O
4. 使用了高效的数据结构。每种数据类型底层都做了优化



**什么是多路I/O复用？有什么优点**



**为什么选用单线程？**

1. 避免了过多的上下文切换开销
2. 避免了同步机制的开销。如果Redis是多线程的，需要考虑数据同步问题，则必然引入同步机制，导致在操作数据时带来更多的开销
3. 实现简单，方便维护。如果Redis使用多线程，那么底层的数据结构的设计必须考虑线程安全的问题



**Redis6.0为何引入多线程**

1. 可以充分利用服务器的CPU资源，单线程模式下只能利用一个CPU
2. 多线程任务可以分摊Redis同步I/O的负荷



### 7、什么是缓存一致性？

一个变量在多个cpu中都存在缓存时，那么可能存在缓存不一致的问题。当某个cpu修改更新这个变量时，但其他的cpu中缓存并没有改变，这就是缓存一致性问题。



它有两种解决办法：

1.通过在总线上加锁的方式

2.通过缓存一致性协议



在早期的CPU中，是通过在总线上加LOCK锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU对其它部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。但是由于加锁期间，其他cpu无法访问，导致效率低下



所以出现了缓存一致性协议，它保证了每个缓存中使用的共享变量的副本是一致的。

它的核心思想：当CPU向内存写入数据时，如果发现操作的变量时共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存是无效的，那么它就会从内存重新读取。

### 8、缓存和数据库(MySQL)双写一致性问题



### 9、Redis事务

它的原理是将一个事务范围内的若干个命令发给Redis，然后再让Redis依次执行这些命令。

它通过MULTI命令开启事务，在开启事务的时候，每次操作的命令都会被插入到一个队列中，这些命令不会被真正地执行，使用EXEC命令进行提交事务。

注意一个事务范围内的命令出错不会影响其他命令的执行，不保证原子性

```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a 1
QUEUED
127.0.0.1:6379> set b 1 2
QUEUED
127.0.0.1:6379> set c 3
QUEUED
127.0.0.1:6379> exec
1) OK
2) (error) ERR syntax error
3) OK
```

**watch命令**

它可以监控一个或者多个键，一旦其中有一个键被修改，之后的事务就不会被执行。



### 10、Redis的key过期了，是否马上会删除

并不会马上删除，Redis是有过期删除策略的

1.定期删除

Redis定时去删除过期数据

2.惰性删除

当客户端发送请求查询某一个key时，检查key是否过期，如果过期了，则删除该key。将删除数据的主动权交给了客户端。







## MySQL

### 1、MySQL存储引擎

#### MyISAM和InnoDB的区别

| 对比项 | MyISAM               | InnoDB             |
| :----- | -------------------- | ------------------ |
| 事务   | 不支持               | 支持               |
| 外键   | 不支持               | 支持               |
| 锁     | 表级锁，不支持行级锁 | 行级锁，支持表级锁 |
| 索引   | 非聚簇索引           | 聚簇索引           |

#### MyISAM和InnoDB的适用场景

MyISAM适合场景

1. 没有事务
2. 查询非常频繁，对数据执行增删改的操作不多
3. 频繁执行全表count的语句。InnoDB不保存表的具体行数，所以select count(*) from table会全表扫描，而MyISAM用一个变量保存了整个表的行数。



InnoDB适合场景

1. 可靠性比较高，支持事务
2. 适合数据增删改频繁



#### MyISAM和InnoDB的索引实现

**MyISAM索引实现**

主键索引：MyISAM采用B+Tree作为索引结构，叶子节点的data域存放着数据记录的地址。它的数据文件(myd文件)和索引文件(myi文件)分开储存的。属于非聚簇索引



**InnoDB索引实现**

主键索引：InnoDB也是采用B+Tree作为索引结构，叶子节点data域保存着完整的数据记录。它的数据文件和索引文件是放在一起的(ibd文件)。属于聚簇索引



### 2、索引

#### 何为索引？有什么用？优缺点？

索引用于快速查询和检索数据的数据结构。

索引的作用就相当于目录，它可以快速地帮我们找到数据的位置



优点：加快数据检索的速度，减少服务器需要扫描的行数

缺点：创建索引和维护索引需要耗费时间。索引是存储到磁盘文件上的，所以需要耗费一些存储空间

#### 索引数据结构

常见的索引数据结构有：Hash、B树、B+树



**Hash**

通过哈希算法可以快速找到数据的index位置。

如果发生了哈希冲突，则采用拉链法来解决。（这里可以引申到 JDK 上的 HashMap）

最大的缺点：不支持顺序和范围查询。它只能精确地查询。无法用于分组和排序



**B树**

![B树](D:\github\MyKnowledgeRepository\img\picture\B树.png)



B树的特征：

1. 每个节点最多m个孩子（m被称为树的阶，m的值取决于磁盘页的大小）
2. 每个节点最多存储m-1个关键字。根节点至少一个关键字，非根节点至少m/2个关键字
3. 每个节点的关键字都是从小到大排序的。
4. 所有叶子节点都位于同一层

拿上图来说，8和12有三个子节点，所以阶数为3



**B+树**

![B+树](D:\github\MyKnowledgeRepository\img\picture\B+树.png)

![B+树](D:\github\MyKnowledgeRepository\img\picture\B+树2.png)



B+树与B树有什么区别？

1. B树所有的节点都存放键(key)也存放数据(data)，B+树只有叶子节点才存放key和data，其他节点只存放key
2. B树的叶子节点都是独立的，B+树有一条引用链指向它相邻的叶子节点
3. B树的检索过程相当于对范围内的每个节点的关键字做二分查找，可能还没到叶子节点，检索就结束了；B+树的检索效率就很稳定，任何查找都是从根节点到叶子节点的过程。



在MySQL中。MyISAM引擎和InnoDB引擎都是采用B+树作为索引结构



#### 索引为什么采用B+树

回答这个问题前，那我们来看看其他结构作为索引时的优缺点

1. 全部遍历，时间复杂度为O(n)
2. hash：优点：增删改查为O(1),只支持精确查找，缺点：不支持范围查询
3. 二叉查找树：优点:O(log2(n))，查找次数为树的高度。缺点：如果二叉查找树变成线性结构，时间复杂度为O(n)
4. 平衡二叉树：数据量越大导致树越高，树高问题导致磁盘I/O过多
5. B树：优点：每个节点可以有多个子节点，可以控制树的高度，比二叉平衡树减少磁盘I/O次数。缺点：数据库索引是存储在磁盘上的，它的所有节点都存放着索引和数据，它一次性读入内存需要查找的关键字也就越少，当加载索引的时候，需要加载更多的磁盘页，加大磁盘I/O的次数。
6. B+树：只有最底层的叶子节点（文件）保存数据，非叶子节点只保存索引，不保存实际的数据，那它一次性读入内存需要查找的关键字也就越多，磁盘I/O次数降低。并且它的查询也更加稳定，所以任何关键字的查找必须从根结点到叶子结点。而且B+树的叶子节点组成了一个链表，方便遍历查询。



#### 索引类型

**主键索引**

数据表使用的主键列就是主键索引

一张数据表只有一个主键列，并且数据不能为空，不能重复

在MySQL的InnoDB的表中，如果没有指定主键，InnoDB会自动检查表中是否有唯一索引的字段，如果有，把该字段设为默认主键，如果没有，创建一个6字节的自增主键



**二级索引（辅助索引）**

二级索引又称为辅助索引，因为二级索引的叶子节点存储的是主键。也就是说，通过二级索引可以定位主键的位置。



唯一索引、普通索引、前缀索引都属于二级索引

唯一索引：唯一索引的属性列不能出现重复数据，但可以为Null，一张表允许创建多个唯一索引。建立唯一索引大部分是为了这一属性列的数据唯一，而不是为了查询效率。

普通索引：一个索引只包含单个列。普通索引允许数据重复和Null，一张表可以创建多个普通索引，它的唯一作用是为了快速查询数据。

前缀索引：前缀索引只适用于字符类型的数据。就是对文本前面几个字符创建索引。



#### 聚簇索引与非聚簇索引

**聚簇索引**

聚簇索引即索引结构和数据一起存放的索引，主键索引就是聚簇索引



优点：

速度非常快，一旦定位到了索引，就定位到了数据



缺点：

更新代价大。如果索引列的数据被修改时，对应的索引也就将修改。而且聚簇索引的叶子节点还存放着数据，修改代价是比较大的。



**非聚簇索引**

非聚簇索引即索引结构和数据分开存放的索引。



优点：

更新代价小。非聚簇索引的叶子节点是不存放数据

缺点：

可能会二次查询（即回表）。当查找到索引对应的主键后，可能还需要根据主键再到数据文件或者表中查询。（这是非聚簇索引最大的缺点）



#### 什么叫回表？

所谓的回表就是当我们使用非聚簇索引查询数据时，检索出来的数据可能包含其他列，但走的索引树的叶子节点只能查询到当前列以及主键id，所以需要根据主键id再去查一遍数据，得到我们所需要的数据列。



比如：select name,age from table where name='小力哥'

SQL走name的索引，但走的索引树叶子节点只能查询到name和主键id值，所以需要根据主键id值再去查一遍数据，

执行的流程是先查询到name索引上的‘小力哥’，然后找到他的id是3，最后去主键索引，找到id为3的对应的age值。



#### 如何避免回表？（非聚簇索引一定会回表查询吗？）

想要避免回表，可以使用覆盖索引。所谓的覆盖索引就是索引包含了所需要查询的字段。

比如我建了一个name和age联合索引，刚好我所需要查询的就是name和age列，这些数据都存在索引树的叶子节点上，就不需要回表操作了。



#### 联合索引的索引最左匹配原则

所谓的联合索引就是多列索引。比如(a,b,c,d)

MySQL会一直向右匹配直到遇到范围查询（<、>、between、like）就停止匹配，后续退化为线性查找。

如，有联合索引(a,b,c,d)，查询条件为a=1 and b=2 and c<3 and d=4，则会在节点依次命中 a、b、c，不会命中d。（因为c是范围查询）



#### 建立了索引 a,b,c，那么直接访问 b,c，索引生效吗？

不会生效。联合索引必须满足最左匹配原则



#### 如何定位慢查询sql语句

1. 根据慢日志定位慢查询sql
2. 适用explain等工具分析sql



#### 索引优化

1. 在查询时，尽量让sql走索引。比如：对于Text、Varchar类型的列使用前缀索引效率高；使用覆盖索引，让索引包含所需要查询的字段
2. 在使用多列作为查询条件时，使用多列索引比单列索引效率高
3. 让选择性强的索引放在前面



#### 索引是建立的越多越好吗？

不是。

1. 小表是不需要建立索引。
2. 数据变更是需要维护索引的。更多的索引意味着更多的维护成本，更多的索引也意味着更多的空间



### 3、事务

#### 事务的四大特性（ACID）

原子性。要么都做，要么都不做。

一致性。事务对读取同一个数据，结果应该是相同的。

隔离性。一个事务的执行不能被其他事务干扰。

持久性。一旦事务提交，所做的修改永久保存在数据库中。

#### 事务的并发问题

1. 丢失修改。一个事务的更新操作被另一个事务的更新操作给替换了。

   如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

   ![丢失修改](D:\github\MyKnowledgeRepository\img\picture\丢失修改.png)

   

2. 脏读。当前事务读取到另一个事务未提交的数据。

   如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据

   ![脏读](D:\github\MyKnowledgeRepository\img\picture\脏读.png)

   

3. 不可重复读。一个事务读取同一数据集时，在这事务未结束时，另一个事务也访问了同一数据，并做了修改，导致第一个事务两次读取的结果不一致。

   例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同

   ![不可重复读](D:\github\MyKnowledgeRepository\img\picture\不可重复读.png)

   

4. 幻影读。幻影读也属于不可重复读的一种。一个事务T读取同一范围内数据，另一个事务在这个范围内插入或者删除了一条数据，当事务T再次读取时，两次读取结果不同。

   ![幻影读](D:\github\MyKnowledgeRepository\img\picture\幻影读.png)

   

#### 事务隔离级别

回答这个问题前，先回答事务并发的问题。



事物隔离级别是解决事务并发问题的

1. 未提交读(read uncommited)。事务的修改即使是未提交读，对其他事务也是可见的。
2. 提交读(read commited)。一个事务只能读取已提交的事务所做的修改。可解决脏读问题
3. 可重复读(repeatable read)。保证一个事务读取同一个数据结果是一样的。可解决不可重复读的问题
4. 串行化(serielizable)。该隔离级别需要加锁，保证同一时间只有一个事务执行。可解决幻影读问题



0表示不能解决，1表示能解决

|            | 未提交读 | 提交读 | 可重复读 | 串行化 |
| ---------- | -------- | ------ | -------- | ------ |
| 脏读       | 0        | 1      | 1        | 1      |
| 不可重复读 | 0        | 0      | 1        | 1      |
| 幻影读0    | 0        | 0      | 0        | 1      |



### 4、锁

#### 锁的分类

按粒度划分：表级锁、行级锁

按锁级别划分：共享锁、排它锁

按使用方式划分：乐观锁、悲观锁



**表级锁和行级锁**

表级锁：锁住整张表

行级锁：锁住表中的某一个行



**共享锁和排它锁**

共享锁：又称读锁。一个事务对数据对象加了读锁，可以对该对象执行读取操作，但是不能进行更新操作。加锁期间，其他事务能对它加读锁，但不能加写锁。

排它锁：又称写锁。一个事务对数据对象加了写锁之后，可以对该对象执行读取和更新操作。加锁期间，其他事务不能对它加任何锁。



**乐观锁和悲观锁**

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题

乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候，判断一下在此期间别人有没有修改过数据，如果有，则放弃操作，否则执行操作。Redis使用的就是乐观锁

悲观锁：悲观锁在操作数据时非常悲观，认为别人会同时修改数据。因此操作数据时，直接把数据锁住，直到操作完成后才释放锁。上锁期间其他人不可修改数据



#### 说说你对MySQL锁的理解？

在InnoDB引擎下，按锁的粒度分类可以分为行锁和表锁。

行锁实际上是作用在索引之上的，当我们的SQL命中索引，那锁住的就是命中条件列的索引（行锁）。

如果没命中索引，我们锁的就是整个索引树（表锁）。

行锁又可以简单分为读锁（共享锁，S锁）和写锁（排它锁，X锁）。

读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改。

写锁是排它，写锁会阻塞其他写锁和读锁。



#### 并发控制MVCC

多版本并发控制(MVCC)，是MySQL的InnoDB存储引擎实现隔离级别一种具体方式。用于实现提交读和可重复读的实现。 

MVCC的思想就是保存历史版本，通过对数据多个版本的管理来实现数据库的并发控制。

它的解决以下问题：

1. 通过MVCC可以让读写不阻塞，提高事务的并发能力。为事务分配一个时间戳，每个修改保存一个版本，版本与事务时间戳是管理的，读操作只能读取该事务开始前的数据库的快照。
2. 能降低死锁的概率。MVCC采用乐观锁的方式，读取数据并不需要加锁，对于写操作，也只锁住必要的行。
3. 解决一致性读的问题。一致性读也称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交的更新结果，而不能看到这个时间点之后的更新结果。



#### Next-Keys Locks

next-key locks是mysql的innodb一种锁的实现。

MVCC不能解决幻读的问题，next-key locks就是为解决这个问题而存在的。在可重复读的隔离级别下，使用MVCC + next-key locks可以解决幻影读的问题。



#### 两段锁协议

两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段(加锁阶段)和衰退阶段(解锁阶段)

加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。

解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

两段封锁法可以这样来实现：事务开始后就处于加锁阶段，一直到执行ROLLBACK和COMMIT之前都是加锁阶段。ROLLBACK和COMMIT使事务进入解锁阶段，即在ROLLBACK和COMMIT模块中DBMS释放所有封锁。

两段锁协议可以保证事务串行化执行。

两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

![](https://bkimg.cdn.bcebos.com/pic/ac6eddc451da81cb4a2cd0e25266d016082431d2?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U2MA==,g_7,xp_5,yp_5/format,f_auto)



